---
source: compiler/tests/snapshot_codegen.rs
expression: cpp
---
// Generated by pcc (Pipit Compiler Collection)
#include <pipit.h>
#include <pipit_shell.h>
#include <cstdio>

static constexpr float _const_lp_coeff[] = {0.25f, 0.5f, 0.25f};

static std::atomic<bool> _stop{false};
static std::atomic<int> _exit_code{0};
static std::atomic<bool> _start{false};

static bool _stats = false;
static pipit::TaskStats _stats_analyzer;
static FILE* _probe_output_file = nullptr;

void task_analyzer() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(1000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(1000.0);
    uint64_t _iter_idx = 0;
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_analyzer.record_miss(); continue; }
        if (_stats) _stats_analyzer.record_tick(_timer.last_latency());
        auto _actor_0 = Actor_constant<float>{0, 3};
        auto _actor_2 = Actor_fir<float>{std::span<const float>(_const_lp_coeff, 3), 3};
        auto _actor_4 = Actor_fft{64};
        auto _actor_3 = Actor_stdout<float>{};
        auto _actor_5 = Actor_mag{64};
        auto _actor_6 = Actor_stdout<float>{};
        pipit::detail::set_actor_iteration_index(_iter_idx++);
        static float _e0_1[192];
        static float _e2_3[64];
        static cfloat _e4_5[192];
        static float _e5_6[192];
        // fork: sig (zero-copy)
        for (int _r = 0; _r < 64; ++_r) {
            if (_actor_0.operator()(nullptr, &_e0_1[_r * 3]) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'constant' in task 'analyzer' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_2.operator()(&_e0_1[_r * 3], &_e2_3[_r * 1]) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'fir' in task 'analyzer' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
        }
        for (int _r = 0; _r < 3; ++_r) {
            if (_actor_4.operator()(&_e0_1[_r * 64], &_e4_5[_r * 64]) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'fft' in task 'analyzer' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
        }
        for (int _r = 0; _r < 64; ++_r) {
            if (_actor_3.operator()(&_e2_3[_r * 1], nullptr) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'stdout' in task 'analyzer' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
        }
        for (int _r = 0; _r < 3; ++_r) {
            if (_actor_5.operator()(&_e4_5[_r * 64], &_e5_6[_r * 64]) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'mag' in task 'analyzer' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
        }
        for (int _r = 0; _r < 192; ++_r) {
            if (_actor_6.operator()(&_e5_6[_r * 1], nullptr) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'stdout' in task 'analyzer' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
        }
    }
}

int main(int argc, char* argv[]) {
    static const pipit::TaskDesc _task_descs[] = {
        {"analyzer", task_analyzer, &_stats_analyzer},
    };
    pipit::ProgramDesc _desc{};
    _desc.state = {&_stop, &_exit_code, &_start, &_stats, &_probe_output_file};
    _desc.params = std::span<const pipit::ParamDesc>{};
    _desc.tasks = _task_descs;
    _desc.buffers = std::span<const pipit::BufferStatsDesc>{};
    _desc.probes = std::span<const pipit::ProbeDesc>{};
    _desc.overrun_policy = "drop";
    _desc.mem_allocated = 67108864;
    _desc.mem_used = 0;
    return pipit::shell_main(argc, argv, _desc);
}
