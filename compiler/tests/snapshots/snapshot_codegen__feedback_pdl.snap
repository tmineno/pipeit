---
source: compiler/tests/snapshot_codegen.rs
expression: cpp
---
// Generated by pcc (Pipit Compiler Collection)
#include <pipit.h>
#include <pipit_shell.h>
#include <cstdio>

static std::atomic<float> _param_alpha_write(0.5f);
static std::atomic<float> _param_alpha_read(0.5f);

static std::atomic<bool> _stop{false};
static std::atomic<int> _exit_code{0};
static std::atomic<bool> _start{false};

static bool _stats = false;
static pipit::TaskStats _stats_iir;
static FILE* _probe_output_file = nullptr;
static bool _probe_tap_enabled = false;

void task_iir() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(1000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(1000.0);
    uint64_t _iter_idx = 0;
    float _fb_6_7[1] = {0};
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_iir.record_miss(); continue; }
        if (_stats) _stats_iir.record_tick(_timer.last_latency());
        auto _actor_0 = Actor_constant<float>{0, 1};
        auto _actor_6 = Actor_delay<float>{1, 0};
        auto _actor_5 = Actor_stdout<float>{};
        pipit::detail::set_actor_iteration_index(_iter_idx++);
        _param_alpha_read.store(_param_alpha_write.load(std::memory_order_acquire), std::memory_order_release);
        float _param_alpha_val = _param_alpha_read.load(std::memory_order_acquire);
        static float _e0_1[1];
        static float _e1_2[1];
        static float _e2_3[1];
        if (_actor_0.operator()(nullptr, _e0_1) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'constant' in task 'iir' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        // fork: fb (zero-copy)
        float _in_1[2];
        _in_1[0] = (_e0_1)[0];
        _in_1[1] = (_fb_6_7)[0];
        if (Actor_add<float>{}(_in_1, _e1_2) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'add' in task 'iir' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        if (Actor_mul<float>{_param_alpha_val, 1}.operator()(_e1_2, _e2_3) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'mul' in task 'iir' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        // fork: out (zero-copy)
        #ifndef NDEBUG
        if (_probe_tap_enabled) {
            for (int _pi = 0; _pi < 1; ++_pi)
                fprintf(_probe_output_file, "[probe:tap] %f\n", (_e2_3)[_pi]);
            fflush(_probe_output_file);
        }
        #endif
        if (_actor_6.operator()(_e2_3, _fb_6_7) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'delay' in task 'iir' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        if (_actor_5.operator()(_e2_3, nullptr) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'stdout' in task 'iir' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
    }
}

int main(int argc, char* argv[]) {
    static const pipit::ParamDesc _param_descs[] = {
        {"alpha", [](const char* v) -> bool { try { _param_alpha_write.store(std::stof(v), std::memory_order_release); return true; } catch (...) { return false; } }},
    };
    static const pipit::TaskDesc _task_descs[] = {
        {"iir", task_iir, &_stats_iir},
    };
    static const pipit::ProbeDesc _probe_descs[] = {
        {"tap", &_probe_tap_enabled},
    };
    pipit::ProgramDesc _desc{};
    _desc.state = {&_stop, &_exit_code, &_start, &_stats, &_probe_output_file};
    _desc.params = _param_descs;
    _desc.tasks = _task_descs;
    _desc.buffers = std::span<const pipit::BufferStatsDesc>{};
    _desc.probes = _probe_descs;
    _desc.overrun_policy = "drop";
    _desc.mem_allocated = 16777216;
    _desc.mem_used = 0;
    return pipit::shell_main(argc, argv, _desc);
}
