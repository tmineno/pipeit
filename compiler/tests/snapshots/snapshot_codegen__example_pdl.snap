---
source: compiler/tests/snapshot_codegen.rs
expression: cpp
---
// Generated by pcc (Pipit Compiler Collection)
#include <pipit.h>
#include <pipit_shell.h>
#include <cstdio>

static constexpr float _const_coeff[] = {0.1f, 0.2f, 0.4f, 0.2f, 0.1f};
static constexpr auto _const_fft_size = 256;

static std::atomic<float> _param_gain_write(1);
static std::atomic<float> _param_gain_read(1);

static pipit::RingBuffer<float, 512, 1> _ringbuf_signal;

static std::atomic<bool> _stop{false};
static std::atomic<int> _exit_code{0};
static std::atomic<bool> _start{false};

static bool _stats = false;
static pipit::TaskStats _stats_capture;
static pipit::TaskStats _stats_drain;
static FILE* _probe_output_file = nullptr;
static bool _probe_filtered_enabled = false;

void task_capture() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(10000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(10000000.0);
    uint64_t _iter_idx = 0;
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_capture.record_miss(); continue; }
        if (_stats) _stats_capture.record_tick(_timer.last_latency());
        auto _actor_0 = Actor_constant<float>{0, 256};
        auto _actor_2 = Actor_fft{256};
        auto _actor_4 = Actor_c2r{256};
        auto _actor_8 = Actor_mag{256};
        auto _actor_5 = Actor_fir<float>{std::span<const float>(_const_coeff, 5), 5};
        auto _actor_9 = Actor_stdout<float>{};
        for (int _k = 0; _k < 1000; ++_k) {
            pipit::detail::set_actor_iteration_index(_iter_idx++);
            _param_gain_read.store(_param_gain_write.load(std::memory_order_acquire), std::memory_order_release);
            float _param_gain_val = _param_gain_read.load(std::memory_order_acquire);
            static float _e0_1[1280];
            static float _e1_2[1280];
            static cfloat _e2_3[1280];
            static float _e4_5[1280];
            static float _e5_6[256];
            static float _e8_9[1280];
            auto _actor_1 = Actor_mul<float>{_param_gain_val, 256};
            // fork: raw (zero-copy)
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_0.operator()(nullptr, &_e0_1[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'constant' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                if (_actor_1.operator()(&_e0_1[_r * 256], &_e1_2[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'mul' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                if (_actor_2.operator()(&_e1_2[_r * 256], &_e2_3[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fft' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                if (_actor_4.operator()(&_e2_3[_r * 256], &_e4_5[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'c2r' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                if (_actor_8.operator()(&_e2_3[_r * 256], &_e8_9[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'mag' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 256; ++_r) {
                if (_actor_5.operator()(&_e4_5[_r * 5], &_e5_6[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fir' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 1280; ++_r) {
                if (_actor_9.operator()(&_e8_9[_r * 1], nullptr) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'stdout' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            #ifndef NDEBUG
            if (_probe_filtered_enabled) {
                for (int _pi = 0; _pi < 256; ++_pi)
                    fprintf(_probe_output_file, "[probe:filtered] %f\n", (_e5_6)[_pi]);
                fflush(_probe_output_file);
            }
            #endif
            int _rb_retry_6_7 = 0;
            while (true) {
                if (!_ringbuf_signal.write(_e5_6, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_6_7 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'capture' failed to write 256 token(s) to shared buffer 'signal'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
        }
    }
}

void task_drain() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(10000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(10000000.0);
    uint64_t _iter_idx = 0;
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_drain.record_miss(); continue; }
        if (_stats) _stats_drain.record_tick(_timer.last_latency());
        auto _actor_11 = Actor_decimate<float>{256};
        auto _actor_12 = Actor_csvwrite{"output.csv"};
        for (int _k = 0; _k < 1000; ++_k) {
            pipit::detail::set_actor_iteration_index(_iter_idx++);
            static float _e10_11[256];
            static float _e11_12[1];
            int _rb_retry_10_11 = 0;
            while (true) {
                if (!_ringbuf_signal.read(0, _e10_11, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_10_11 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'drain' failed to read 256 token(s) from shared buffer 'signal'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
            if (_actor_11.operator()(_e10_11, _e11_12) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'decimate' in task 'drain' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_12.operator()(_e11_12, nullptr) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'csvwrite' in task 'drain' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
        }
    }
}

int main(int argc, char* argv[]) {
    static const pipit::ParamDesc _param_descs[] = {
        {"gain", [](const char* v) -> bool { try { _param_gain_write.store(std::stof(v), std::memory_order_release); return true; } catch (...) { return false; } }},
    };
    static const pipit::TaskDesc _task_descs[] = {
        {"capture", task_capture, &_stats_capture},
        {"drain", task_drain, &_stats_drain},
    };
    static const pipit::BufferStatsDesc _buffer_descs[] = {
        {"signal", []() -> size_t { return _ringbuf_signal.available(); }, sizeof(float)},
    };
    static const pipit::ProbeDesc _probe_descs[] = {
        {"filtered", &_probe_filtered_enabled},
    };
    pipit::ProgramDesc _desc{};
    _desc.state = {&_stop, &_exit_code, &_start, &_stats, &_probe_output_file};
    _desc.params = _param_descs;
    _desc.tasks = _task_descs;
    _desc.buffers = _buffer_descs;
    _desc.probes = _probe_descs;
    _desc.overrun_policy = "drop";
    _desc.mem_allocated = 67108864;
    _desc.mem_used = 2048;
    return pipit::shell_main(argc, argv, _desc);
}
