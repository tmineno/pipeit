---
source: compiler/tests/snapshot_codegen.rs
expression: cpp
---
// Generated by pcc (Pipit Compiler Collection)
#include <pipit.h>
#include <pipit_shell.h>
#include <cstdio>

static constexpr float _const_lp_coeff[] = {0.1f, 0.2f, 0.4f, 0.2f, 0.1f};
static constexpr float _const_bp_coeff[] = {0.05f, -0.1f, 0.3f, -0.1f, 0.05f};

static std::atomic<float> _param_agc_gain_write(1);
static std::atomic<float> _param_agc_gain_read(1);

static pipit::RingBuffer<int32_t, 256, 1> _ringbuf_ctl;
static pipit::RingBuffer<float, 256, 1> _ringbuf_data_buf;
static pipit::RingBuffer<float, 512, 1> _ringbuf_filtered;
static pipit::RingBuffer<float, 512, 1> _ringbuf_narrow;
static pipit::RingBuffer<float, 256, 1> _ringbuf_sync_buf;
static pipit::RingBuffer<float, 512, 1> _ringbuf_wideband;

static std::atomic<bool> _stop{false};
static std::atomic<int> _exit_code{0};
static std::atomic<bool> _start{false};

static bool _stats = false;
static pipit::TaskStats _stats_analysis;
static pipit::TaskStats _stats_capture;
static pipit::TaskStats _stats_monitor;
static FILE* _probe_output_file = nullptr;
static bool _probe_agc_out_enabled = false;
static bool _probe_bp_out_enabled = false;
static bool _probe_sync_probe_enabled = false;
static bool _probe_data_probe_enabled = false;

void task_analysis() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(10000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(10000000.0);
    uint64_t _iter_idx = 0;
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_analysis.record_miss(); continue; }
        if (_stats) _stats_analysis.record_tick(_timer.last_latency());
        auto _actor_24 = Actor_decimate<float>{256};
        auto _actor_29 = Actor_decimate<float>{256};
        auto _actor_32 = Actor_decimate<float>{256};
        auto _actor_30 = Actor_csvwrite{"narrow.csv"};
        auto _actor_33 = Actor_csvwrite{"wideband.csv"};
        auto _actor_26 = Actor_csvwrite{"filtered.csv"};
        auto _actor_27 = Actor_stdout<float>{};
        for (int _k = 0; _k < 1000; ++_k) {
            pipit::detail::set_actor_iteration_index(_iter_idx++);
            static float _e23_24[256];
            static float _e24_25[1];
            static float _e28_29[256];
            static float _e29_30[1];
            static float _e31_32[256];
            static float _e32_33[1];
            int _rb_retry_23_24 = 0;
            while (true) {
                if (!_ringbuf_filtered.read(0, _e23_24, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_23_24 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'analysis' failed to read 256 token(s) from shared buffer 'filtered'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
            int _rb_retry_28_29 = 0;
            while (true) {
                if (!_ringbuf_narrow.read(0, _e28_29, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_28_29 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'analysis' failed to read 256 token(s) from shared buffer 'narrow'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
            int _rb_retry_31_32 = 0;
            while (true) {
                if (!_ringbuf_wideband.read(0, _e31_32, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_31_32 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'analysis' failed to read 256 token(s) from shared buffer 'wideband'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
            if (_actor_24.operator()(_e23_24, _e24_25) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'decimate' in task 'analysis' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_29.operator()(_e28_29, _e29_30) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'decimate' in task 'analysis' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_32.operator()(_e31_32, _e32_33) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'decimate' in task 'analysis' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            // fork: dec_f (zero-copy)
            if (_actor_30.operator()(_e29_30, nullptr) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'csvwrite' in task 'analysis' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_33.operator()(_e32_33, nullptr) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'csvwrite' in task 'analysis' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_26.operator()(_e24_25, nullptr) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'csvwrite' in task 'analysis' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_27.operator()(_e24_25, nullptr) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'stdout' in task 'analysis' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
        }
    }
}

void task_capture() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(10000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(10000000.0);
    uint64_t _iter_idx = 0;
    float _fb_10_11[1] = {0};
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_capture.record_miss(); continue; }
        if (_stats) _stats_capture.record_tick(_timer.last_latency());
        auto _actor_0 = Actor_constant<float>{0, 256};
        auto _actor_14 = Actor_constant<float>{0, 256};
        auto _actor_1 = Actor_fft{256};
        auto _actor_15 = Actor_fft{256};
        auto _actor_16 = Actor_c2r{256};
        auto _actor_3 = Actor_c2r{256};
        auto _actor_12 = Actor_mag{256};
        auto _actor_4 = Actor_fir<float>{std::span<const float>(_const_lp_coeff, 5), 5};
        auto _actor_13 = Actor_stdout<float>{};
        auto _actor_18 = Actor_fir<float>{std::span<const float>(_const_bp_coeff, 5), 5};
        auto _actor_21 = Actor_fir<float>{std::span<const float>(_const_lp_coeff, 5), 5};
        auto _actor_10 = Actor_delay<float>{1, 0};
        for (int _k = 0; _k < 1000; ++_k) {
            pipit::detail::set_actor_iteration_index(_iter_idx++);
            _param_agc_gain_read.store(_param_agc_gain_write.load(std::memory_order_acquire), std::memory_order_release);
            float _param_agc_gain_val = _param_agc_gain_read.load(std::memory_order_acquire);
            static float _e0_1[1280];
            static cfloat _e1_2[1280];
            static float _e3_4[1280];
            static float _e4_5[256];
            static float _e5_6[256];
            static float _e6_7[256];
            static float _e12_13[1280];
            static float _e14_15[1280];
            static cfloat _e15_16[1280];
            static float _e16_17[1280];
            static float _e18_19[256];
            static float _e21_22[256];
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_0.operator()(nullptr, &_e0_1[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'constant' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            // fork: fb (zero-copy)
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_14.operator()(nullptr, &_e14_15[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'constant' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_1.operator()(&_e0_1[_r * 256], &_e1_2[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fft' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_15.operator()(&_e14_15[_r * 256], &_e15_16[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fft' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            // fork: spec0 (zero-copy)
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_16.operator()(&_e15_16[_r * 256], &_e16_17[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'c2r' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_3.operator()(&_e1_2[_r * 256], &_e3_4[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'c2r' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 5; ++_r) {
                if (_actor_12.operator()(&_e1_2[_r * 256], &_e12_13[_r * 256]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'mag' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            // fork: raw1 (zero-copy)
            for (int _r = 0; _r < 256; ++_r) {
                if (_actor_4.operator()(&_e3_4[_r * 5], &_e4_5[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fir' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 1280; ++_r) {
                if (_actor_13.operator()(&_e12_13[_r * 1], nullptr) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'stdout' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 256; ++_r) {
                if (_actor_18.operator()(&_e16_17[_r * 5], &_e18_19[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fir' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 256; ++_r) {
                if (_actor_21.operator()(&_e16_17[_r * 5], &_e21_22[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fir' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            for (int _r = 0; _r < 256; ++_r) {
                float _in_5[2];
                _in_5[0] = (&_e4_5[_r * 1])[0];
                _in_5[1] = (&_fb_10_11[_r * 1])[0];
                if (Actor_add<float>{}(_in_5, &_e5_6[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'add' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            #ifndef NDEBUG
            if (_probe_bp_out_enabled) {
                for (int _pi = 0; _pi < 256; ++_pi)
                    fprintf(_probe_output_file, "[probe:bp_out] %f\n", (_e18_19)[_pi]);
                fflush(_probe_output_file);
            }
            #endif
            int _rb_retry_21_22 = 0;
            while (true) {
                if (!_ringbuf_wideband.write(_e21_22, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_21_22 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'capture' failed to write 256 token(s) to shared buffer 'wideband'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
            auto _actor_6 = Actor_mul<float>{_param_agc_gain_val, 1};
            for (int _r = 0; _r < 256; ++_r) {
                if (_actor_6.operator()(&_e5_6[_r * 1], &_e6_7[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'mul' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            int _rb_retry_19_20 = 0;
            while (true) {
                if (!_ringbuf_narrow.write(_e18_19, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_19_20 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'capture' failed to write 256 token(s) to shared buffer 'narrow'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
            // fork: agc (zero-copy)
            for (int _r = 0; _r < 256; ++_r) {
                #ifndef NDEBUG
                if (_probe_agc_out_enabled) {
                    for (int _pi = 0; _pi < 1; ++_pi)
                        fprintf(_probe_output_file, "[probe:agc_out] %f\n", (&_e6_7[_r * 1])[_pi]);
                    fflush(_probe_output_file);
                }
                #endif
            }
            for (int _r = 0; _r < 256; ++_r) {
                if (_actor_10.operator()(&_e6_7[_r * 1], &_fb_10_11[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'delay' in task 'capture' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            int _rb_retry_8_9 = 0;
            while (true) {
                if (!_ringbuf_filtered.write(_e6_7, 256)) {
                    if (_stop.load(std::memory_order_acquire)) {
                        return;
                    }
                    if (++_rb_retry_8_9 < 1000000) {
                        std::this_thread::yield();
                        continue;
                    }
                    std::fprintf(stderr, "runtime error: task 'capture' failed to write 256 token(s) to shared buffer 'filtered'\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                break;
            }
        }
    }
}

void task_monitor() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(10000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(10000000.0);
    uint64_t _iter_idx = 0;
    int32_t _active_mode = -1;
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_monitor.record_miss(); continue; }
        if (_stats) _stats_monitor.record_tick(_timer.last_latency());
        auto _actor_34 = Actor_constant<float>{0, 1};
        auto _actor_35 = Actor_correlate{};
        auto _actor_36 = Actor_detect{};
        auto _actor_38 = Actor_constant<float>{0, 5};
        auto _actor_39 = Actor_fir<float>{std::span<const float>(_const_lp_coeff, 5), 5};
        auto _actor_42 = Actor_constant<float>{0, 256};
        auto _actor_43 = Actor_fft{256};
        auto _actor_44 = Actor_c2r{256};
        auto _actor_45 = Actor_fir<float>{std::span<const float>(_const_bp_coeff, 5), 5};
        for (int _k = 0; _k < 1000; ++_k) {
            pipit::detail::set_actor_iteration_index(_iter_idx++);
            // Control subgraph
            static float _e34_35[64];
            static float _e35_36[1];
            static int32_t _e36_37[1];
            for (int _r = 0; _r < 64; ++_r) {
                if (_actor_34.operator()(nullptr, &_e34_35[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'constant' in task 'monitor' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            if (_actor_35.operator()(_e34_35, _e35_36) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'correlate' in task 'monitor' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_36.operator()(_e35_36, _e36_37) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'detect' in task 'monitor' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            int32_t _ctrl = _e36_37[0];
            if (_active_mode != -1 && _ctrl != _active_mode) {
            }
            _active_mode = _ctrl;
            switch (_ctrl) {
            case 0: {
                static float _e38_39[5];
                static float _e39_40[1];
                if (_actor_38.operator()(nullptr, _e38_39) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'constant' in task 'monitor' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                if (_actor_39.operator()(_e38_39, _e39_40) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fir' in task 'monitor' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                #ifndef NDEBUG
                if (_probe_sync_probe_enabled) {
                    for (int _pi = 0; _pi < 1; ++_pi)
                        fprintf(_probe_output_file, "[probe:sync_probe] %f\n", (_e39_40)[_pi]);
                    fflush(_probe_output_file);
                }
                #endif
                break;
            }
            case 1: {
                static float _e42_43[1280];
                static cfloat _e43_44[1280];
                static float _e44_45[1280];
                static float _e45_46[256];
                for (int _r = 0; _r < 5; ++_r) {
                    if (_actor_42.operator()(nullptr, &_e42_43[_r * 256]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'constant' in task 'monitor' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                    if (_actor_43.operator()(&_e42_43[_r * 256], &_e43_44[_r * 256]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'fft' in task 'monitor' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                    if (_actor_44.operator()(&_e43_44[_r * 256], &_e44_45[_r * 256]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'c2r' in task 'monitor' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                }
                for (int _r = 0; _r < 256; ++_r) {
                    if (_actor_45.operator()(&_e44_45[_r * 5], &_e45_46[_r * 1]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'fir' in task 'monitor' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                    #ifndef NDEBUG
                    if (_probe_data_probe_enabled) {
                        for (int _pi = 0; _pi < 1; ++_pi)
                            fprintf(_probe_output_file, "[probe:data_probe] %f\n", (&_e45_46[_r * 1])[_pi]);
                        fflush(_probe_output_file);
                    }
                    #endif
                }
                break;
            }
            default: break;
            }
        }
    }
}

int main(int argc, char* argv[]) {
    static const pipit::ParamDesc _param_descs[] = {
        {"agc_gain", [](const char* v) -> bool { try { _param_agc_gain_write.store(std::stof(v), std::memory_order_release); return true; } catch (...) { return false; } }},
    };
    static const pipit::TaskDesc _task_descs[] = {
        {"analysis", task_analysis, &_stats_analysis},
        {"capture", task_capture, &_stats_capture},
        {"monitor", task_monitor, &_stats_monitor},
    };
    static const pipit::BufferStatsDesc _buffer_descs[] = {
        {"ctl", []() -> size_t { return _ringbuf_ctl.available(); }, sizeof(int32_t)},
        {"data_buf", []() -> size_t { return _ringbuf_data_buf.available(); }, sizeof(float)},
        {"filtered", []() -> size_t { return _ringbuf_filtered.available(); }, sizeof(float)},
        {"narrow", []() -> size_t { return _ringbuf_narrow.available(); }, sizeof(float)},
        {"sync_buf", []() -> size_t { return _ringbuf_sync_buf.available(); }, sizeof(float)},
        {"wideband", []() -> size_t { return _ringbuf_wideband.available(); }, sizeof(float)},
    };
    static const pipit::ProbeDesc _probe_descs[] = {
        {"agc_out", &_probe_agc_out_enabled},
        {"bp_out", &_probe_bp_out_enabled},
        {"sync_probe", &_probe_sync_probe_enabled},
        {"data_probe", &_probe_data_probe_enabled},
    };
    pipit::ProgramDesc _desc{};
    _desc.state = {&_stop, &_exit_code, &_start, &_stats, &_probe_output_file};
    _desc.params = _param_descs;
    _desc.tasks = _task_descs;
    _desc.buffers = _buffer_descs;
    _desc.probes = _probe_descs;
    _desc.overrun_policy = "drop";
    _desc.mem_allocated = 134217728;
    _desc.mem_used = 6144;
    return pipit::shell_main(argc, argv, _desc);
}
