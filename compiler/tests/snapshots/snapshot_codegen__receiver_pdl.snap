---
source: compiler/tests/snapshot_codegen.rs
expression: cpp
---
// Generated by pcc (Pipit Compiler Collection)
#include <pipit.h>
#include <pipit_shell.h>
#include <cstdio>

static constexpr float _const_sync_coeff[] = {1, -1, 1, -1};
static constexpr float _const_data_coeff[] = {0.1f, 0.2f, 0.4f, 0.2f, 0.1f};

static pipit::RingBuffer<int32_t, 256, 1> _ringbuf_ctrl;
static pipit::RingBuffer<float, 512, 1> _ringbuf_payload;
static pipit::RingBuffer<float, 256, 1> _ringbuf_sync_result;

static std::atomic<bool> _stop{false};
static std::atomic<int> _exit_code{0};
static std::atomic<bool> _start{false};

static bool _stats = false;
static pipit::TaskStats _stats_logger;
static pipit::TaskStats _stats_receiver;
static FILE* _probe_output_file = nullptr;
static bool _probe_sync_out_enabled = false;
static bool _probe_data_out_enabled = false;

void task_logger() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(1000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(1000.0);
    uint64_t _iter_idx = 0;
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_logger.record_miss(); continue; }
        if (_stats) _stats_logger.record_tick(_timer.last_latency());
        auto _actor_15 = Actor_decimate<float>{2560000};
        auto _actor_16 = Actor_csvwrite{"received.csv"};
        pipit::detail::set_actor_iteration_index(_iter_idx++);
        static float _e14_15[2560000];
        static float _e15_16[1];
        int _rb_retry_14_15 = 0;
        while (true) {
            if (!_ringbuf_payload.read(0, _e14_15, 2560000)) {
                if (_stop.load(std::memory_order_acquire)) {
                    return;
                }
                if (++_rb_retry_14_15 < 1000000) {
                    std::this_thread::yield();
                    continue;
                }
                std::fprintf(stderr, "runtime error: task 'logger' failed to read 2560000 token(s) from shared buffer 'payload'\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            break;
        }
        if (_actor_15.operator()(_e14_15, _e15_16) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'decimate' in task 'logger' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        if (_actor_16.operator()(_e15_16, nullptr) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'csvwrite' in task 'logger' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
    }
}

void task_receiver() {
    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }
    pipit::Timer _timer(10000.0, _stats, 10000);
    pipit::detail::set_actor_task_rate_hz(10000000.0);
    uint64_t _iter_idx = 0;
    int32_t _active_mode = -1;
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_receiver.record_miss(); continue; }
        if (_stats) _stats_receiver.record_tick(_timer.last_latency());
        auto _actor_0 = Actor_constant<float>{0, 1};
        auto _actor_1 = Actor_correlate{};
        auto _actor_2 = Actor_detect{};
        auto _actor_4 = Actor_constant<float>{0, 4};
        auto _actor_5 = Actor_fir<float>{std::span<const float>(_const_sync_coeff, 4), 4};
        auto _actor_8 = Actor_constant<float>{0, 256};
        auto _actor_9 = Actor_fft{256};
        auto _actor_10 = Actor_c2r{256};
        auto _actor_11 = Actor_fir<float>{std::span<const float>(_const_data_coeff, 5), 5};
        for (int _k = 0; _k < 1000; ++_k) {
            pipit::detail::set_actor_iteration_index(_iter_idx++);
            // Control subgraph
            static float _e0_1[64];
            static float _e1_2[1];
            static int32_t _e2_3[1];
            for (int _r = 0; _r < 64; ++_r) {
                if (_actor_0.operator()(nullptr, &_e0_1[_r * 1]) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'constant' in task 'receiver' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
            }
            if (_actor_1.operator()(_e0_1, _e1_2) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'correlate' in task 'receiver' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            if (_actor_2.operator()(_e1_2, _e2_3) != ACTOR_OK) {
                fprintf(stderr, "runtime error: actor 'detect' in task 'receiver' returned ACTOR_ERROR\n");
                _exit_code.store(1, std::memory_order_release);
                _stop.store(true, std::memory_order_release);
                return;
            }
            int32_t _ctrl = _e2_3[0];
            if (_active_mode != -1 && _ctrl != _active_mode) {
            }
            _active_mode = _ctrl;
            switch (_ctrl) {
            case 0: {
                static float _e4_5[4];
                static float _e5_6[1];
                if (_actor_4.operator()(nullptr, _e4_5) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'constant' in task 'receiver' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                if (_actor_5.operator()(_e4_5, _e5_6) != ACTOR_OK) {
                    fprintf(stderr, "runtime error: actor 'fir' in task 'receiver' returned ACTOR_ERROR\n");
                    _exit_code.store(1, std::memory_order_release);
                    _stop.store(true, std::memory_order_release);
                    return;
                }
                #ifndef NDEBUG
                if (_probe_sync_out_enabled) {
                    for (int _pi = 0; _pi < 1; ++_pi)
                        fprintf(_probe_output_file, "[probe:sync_out] %f\n", (_e5_6)[_pi]);
                    fflush(_probe_output_file);
                }
                #endif
                break;
            }
            case 1: {
                static float _e8_9[1280];
                static cfloat _e9_10[1280];
                static float _e10_11[1280];
                static float _e11_12[256];
                for (int _r = 0; _r < 5; ++_r) {
                    if (_actor_8.operator()(nullptr, &_e8_9[_r * 256]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'constant' in task 'receiver' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                    if (_actor_9.operator()(&_e8_9[_r * 256], &_e9_10[_r * 256]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'fft' in task 'receiver' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                    if (_actor_10.operator()(&_e9_10[_r * 256], &_e10_11[_r * 256]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'c2r' in task 'receiver' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                }
                for (int _r = 0; _r < 256; ++_r) {
                    if (_actor_11.operator()(&_e10_11[_r * 5], &_e11_12[_r * 1]) != ACTOR_OK) {
                        fprintf(stderr, "runtime error: actor 'fir' in task 'receiver' returned ACTOR_ERROR\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                    #ifndef NDEBUG
                    if (_probe_data_out_enabled) {
                        for (int _pi = 0; _pi < 1; ++_pi)
                            fprintf(_probe_output_file, "[probe:data_out] %f\n", (&_e11_12[_r * 1])[_pi]);
                        fflush(_probe_output_file);
                    }
                    #endif
                }
                int _rb_retry_12_13 = 0;
                while (true) {
                    if (!_ringbuf_payload.write(_e11_12, 256)) {
                        if (_stop.load(std::memory_order_acquire)) {
                            return;
                        }
                        if (++_rb_retry_12_13 < 1000000) {
                            std::this_thread::yield();
                            continue;
                        }
                        std::fprintf(stderr, "runtime error: task 'receiver' failed to write 256 token(s) to shared buffer 'payload'\n");
                        _exit_code.store(1, std::memory_order_release);
                        _stop.store(true, std::memory_order_release);
                        return;
                    }
                    break;
                }
                break;
            }
            default: break;
            }
        }
    }
}

int main(int argc, char* argv[]) {
    static const pipit::TaskDesc _task_descs[] = {
        {"logger", task_logger, &_stats_logger},
        {"receiver", task_receiver, &_stats_receiver},
    };
    static const pipit::BufferStatsDesc _buffer_descs[] = {
        {"ctrl", []() -> size_t { return _ringbuf_ctrl.available(); }, sizeof(int32_t)},
        {"payload", []() -> size_t { return _ringbuf_payload.available(); }, sizeof(float)},
        {"sync_result", []() -> size_t { return _ringbuf_sync_result.available(); }, sizeof(float)},
    };
    static const pipit::ProbeDesc _probe_descs[] = {
        {"sync_out", &_probe_sync_out_enabled},
        {"data_out", &_probe_data_out_enabled},
    };
    pipit::ProgramDesc _desc{};
    _desc.state = {&_stop, &_exit_code, &_start, &_stats, &_probe_output_file};
    _desc.params = std::span<const pipit::ParamDesc>{};
    _desc.tasks = _task_descs;
    _desc.buffers = _buffer_descs;
    _desc.probes = _probe_descs;
    _desc.overrun_policy = "drop";
    _desc.mem_allocated = 134217728;
    _desc.mem_used = 2048;
    return pipit::shell_main(argc, argv, _desc);
}
