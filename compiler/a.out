// Generated by pcc (Pipit Compiler Collection)
#include <pipit.h>
#include <atomic>
#include <cmath>
#include <chrono>
#include <csignal>
#include <cstdio>
#include <cstring>
#include <limits>
#include <string>
#include <thread>
#include <vector>

#include "/home/tmineno/vibecoding/pipeit/examples/actors.h"

static std::atomic<float> _param_gain(2.5f);

static std::atomic<bool> _stop{false};
static std::atomic<int> _exit_code{0};

static bool _stats = false;
static pipit::TaskStats _stats_audio;

void task_audio() {
    pipit::Timer _timer(48000.0);
    while (!_stop.load(std::memory_order_acquire)) {
        _timer.wait();
        if (_timer.overrun()) { if (_stats) _stats_audio.record_miss(); continue; }
        if (_stats) _stats_audio.record_tick(_timer.last_latency());
        float _param_gain_val = _param_gain.load(std::memory_order_acquire);
        float _e1_2[1];
        float _e0_1[1];
        float _e2_3[1];
        if (Actor_adc{0}.operator()(nullptr, _e0_1) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'adc' in task 'audio' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        if (Actor_mul{_param_gain_val}.operator()(_e0_1, _e1_2) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'mul' in task 'audio' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        if (Actor_mul{_param_gain_val}.operator()(_e1_2, _e2_3) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'mul' in task 'audio' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
        if (Actor_stdout{}(_e2_3, nullptr) != ACTOR_OK) {
            fprintf(stderr, "runtime error: actor 'stdout' in task 'audio' returned ACTOR_ERROR\n");
            _exit_code.store(1, std::memory_order_release);
            _stop.store(true, std::memory_order_release);
            return;
        }
    }
}

int main(int argc, char* argv[]) {
    double _duration_seconds = std::numeric_limits<double>::infinity();
    int _threads = 0;
    std::string _probe_output = "stderr";
    std::vector<std::string> _enabled_probes;

    auto _parse_duration = [](const std::string& s, double* out) -> bool {
        if (s == "inf") { *out = std::numeric_limits<double>::infinity(); return true; }
        std::size_t pos = 0;
        double base = 0.0;
        try {
            base = std::stod(s, &pos);
        } catch (...) {
            return false;
        }
        std::string unit = s.substr(pos);
        if (unit.empty() || unit == "s") { *out = base; return true; }
        if (unit == "m") { *out = base * 60.0; return true; }
        return false;
    };

    for (int i = 1; i < argc; ++i) {
        std::string opt(argv[i]);
        if (opt == "--param") {
            if (i + 1 >= argc) {
                std::fprintf(stderr, "startup error: --param requires name=value\\n");
                return 2;
            }
            std::string arg(argv[++i]);
            auto eq = arg.find('=');
            if (eq == std::string::npos) {
                std::fprintf(stderr, "startup error: --param requires name=value\\n");
                return 2;
            }
            auto name = arg.substr(0, eq);
            auto val = arg.substr(eq + 1);
            if (name == "gain") _param_gain.store(std::stof(val), std::memory_order_release);
            else {
                std::fprintf(stderr, "startup error: unknown param '%s'\\n", name.c_str());
                return 2;
            }
            continue;
        }
        if (opt == "--duration") {
            if (i + 1 >= argc) {
                std::fprintf(stderr, "startup error: --duration requires a value\\n");
                return 2;
            }
            std::string d(argv[++i]);
            if (!_parse_duration(d, &_duration_seconds)) {
                std::fprintf(stderr, "startup error: invalid --duration '%s' (use <sec>, <sec>s, <min>m, or inf)\\n", d.c_str());
                return 2;
            }
            continue;
        }
        if (opt == "--threads") {
            if (i + 1 >= argc) {
                std::fprintf(stderr, "startup error: --threads requires a positive integer\\n");
                return 2;
            }
            try {
                _threads = std::stoi(std::string(argv[++i]));
            } catch (...) {
                std::fprintf(stderr, "startup error: --threads requires a positive integer\\n");
                return 2;
            }
            if (_threads <= 0) {
                std::fprintf(stderr, "startup error: --threads requires a positive integer\\n");
                return 2;
            }
            continue;
        }
        if (opt == "--probe") {
            if (i + 1 >= argc) {
                std::fprintf(stderr, "startup error: --probe requires a name\\n");
                return 2;
            }
            _enabled_probes.emplace_back(argv[++i]);
            continue;
        }
        if (opt == "--probe-output") {
            if (i + 1 >= argc) {
                std::fprintf(stderr, "startup error: --probe-output requires a path\\n");
                return 2;
            }
            _probe_output = std::string(argv[++i]);
            continue;
        }
        if (opt == "--stats") {
            _stats = true;
            continue;
        }
        std::fprintf(stderr, "startup error: unknown option '%s'\\n", argv[i]);
        return 2;
    }

    std::signal(SIGINT, [](int) { _stop.store(true, std::memory_order_release); });

    std::thread _t0(task_audio);

    if (std::isfinite(_duration_seconds)) {
        std::this_thread::sleep_for(std::chrono::duration<double>(_duration_seconds));
        _stop.store(true, std::memory_order_release);
    } else {
        // Run until SIGINT
        while (!_stop.load(std::memory_order_acquire))
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    _t0.join();

    (void)_probe_output; (void)_enabled_probes;

    if (_stats) {
        fprintf(stderr, "[stats] task 'audio': ticks=%lu, missed=%lu (drop), max_latency=%ldns, avg_latency=%ldns\n",
(unsigned long)_stats_audio.ticks, (unsigned long)_stats_audio.missed,
_stats_audio.max_latency_ns, _stats_audio.avg_latency_ns());
    }
    return _exit_code.load(std::memory_order_acquire);
}
