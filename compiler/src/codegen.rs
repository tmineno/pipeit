// codegen.rs — C++ code generation for Pipit programs
//
// Transforms the scheduled SDF program into compilable C++ source code.
// Each task becomes a function with a timer loop, actor firing sequence,
// and intra-task edge buffers. Inter-task communication uses ring buffers.
//
// Preconditions: all upstream phases (parse, resolve, graph, analyze, schedule)
//                completed without errors.
// Postconditions: returns `CodegenResult` with generated C++ source string.
// Failure modes: missing actor metadata or unresolvable types produce diagnostics.
// Side effects: none.

use std::collections::{HashMap, HashSet};
use std::fmt::Write as _;
use std::path::PathBuf;

use crate::analyze::AnalyzedProgram;
use crate::ast::*;
use crate::graph::*;
use crate::registry::{
    ActorMeta, ParamKind, ParamType, PipitType, PortShape, Registry, TokenCount,
};
use crate::resolve::{Diagnostic, ResolvedProgram};
use crate::schedule::*;

// ── Public types ────────────────────────────────────────────────────────────

#[derive(Debug)]
pub struct CodegenResult {
    pub generated: GeneratedCode,
    pub diagnostics: Vec<Diagnostic>,
}

#[derive(Debug)]
pub struct GeneratedCode {
    pub cpp_source: String,
}

#[derive(Debug, Clone)]
pub struct CodegenOptions {
    pub release: bool,
    pub include_paths: Vec<PathBuf>,
}

// ── Public entry point ──────────────────────────────────────────────────────

pub fn codegen(
    program: &Program,
    resolved: &ResolvedProgram,
    graph: &ProgramGraph,
    analysis: &AnalyzedProgram,
    schedule: &ScheduledProgram,
    registry: &Registry,
    options: &CodegenOptions,
) -> CodegenResult {
    let mut ctx = CodegenCtx::new(
        program, resolved, graph, analysis, schedule, registry, options,
    );
    ctx.emit_all();
    ctx.build_result()
}

// ── Internal context ────────────────────────────────────────────────────────

struct CodegenCtx<'a> {
    program: &'a Program,
    resolved: &'a ResolvedProgram,
    graph: &'a ProgramGraph,
    analysis: &'a AnalyzedProgram,
    schedule: &'a ScheduledProgram,
    registry: &'a Registry,
    options: &'a CodegenOptions,
    out: String,
    diagnostics: Vec<Diagnostic>,
}

impl<'a> CodegenCtx<'a> {
    fn new(
        program: &'a Program,
        resolved: &'a ResolvedProgram,
        graph: &'a ProgramGraph,
        analysis: &'a AnalyzedProgram,
        schedule: &'a ScheduledProgram,
        registry: &'a Registry,
        options: &'a CodegenOptions,
    ) -> Self {
        CodegenCtx {
            program,
            resolved,
            graph,
            analysis,
            schedule,
            registry,
            options,
            out: String::with_capacity(8192),
            diagnostics: Vec::new(),
        }
    }

    fn build_result(self) -> CodegenResult {
        CodegenResult {
            generated: GeneratedCode {
                cpp_source: self.out,
            },
            diagnostics: self.diagnostics,
        }
    }

    // ── Top-level emit ──────────────────────────────────────────────────

    fn emit_all(&mut self) {
        self.emit_preamble();
        self.emit_const_storage();
        self.emit_param_storage();
        self.emit_shared_buffers();
        self.emit_stop_flag();
        self.emit_stats_storage();
        self.emit_task_functions();
        self.emit_main();
    }

    // ── Phase 1: Preamble ───────────────────────────────────────────────

    fn emit_preamble(&mut self) {
        self.out
            .push_str("// Generated by pcc (Pipit Compiler Collection)\n");
        self.out.push_str("#include <pipit.h>\n");
        self.out.push_str("#include <atomic>\n");
        self.out.push_str("#include <cerrno>\n");
        self.out.push_str("#include <cmath>\n");
        self.out.push_str("#include <chrono>\n");
        self.out.push_str("#include <csignal>\n");
        self.out.push_str("#include <cstdio>\n");
        self.out.push_str("#include <cstring>\n");
        self.out.push_str("#include <limits>\n");
        self.out.push_str("#include <string>\n");
        self.out.push_str("#include <thread>\n");
        self.out.push_str("#include <unordered_set>\n");
        self.out.push_str("#include <vector>\n");
        self.out.push('\n');

        // Actor headers are included via -include flags from the compiler driver,
        // but add forward declarations for external functions referenced in actors
        for path in &self.options.include_paths {
            let escaped = path
                .to_string_lossy()
                .replace('\\', "\\\\")
                .replace('"', "\\\"");
            let _ = writeln!(self.out, "#include \"{}\"", escaped);
        }
        if !self.options.include_paths.is_empty() {
            self.out.push('\n');
        }
    }

    // ── Phase 2: Const storage ──────────────────────────────────────────

    fn emit_const_storage(&mut self) {
        let mut has_any = false;
        for stmt in &self.program.statements {
            if let StatementKind::Const(c) = &stmt.kind {
                has_any = true;
                match &c.value {
                    Value::Scalar(scalar) => {
                        let _ = writeln!(
                            self.out,
                            "static constexpr auto _const_{} = {};",
                            c.name.name,
                            self.scalar_literal(scalar)
                        );
                    }
                    Value::Array(elems, _) => {
                        let elem_type = self.infer_array_elem_type(elems);
                        let values: Vec<String> =
                            elems.iter().map(|s| self.scalar_literal(s)).collect();
                        let _ = writeln!(
                            self.out,
                            "static constexpr {} _const_{}[] = {{{}}};",
                            elem_type,
                            c.name.name,
                            values.join(", ")
                        );
                    }
                }
            }
        }
        if has_any {
            self.out.push('\n');
        }
    }

    // ── Phase 3: Param storage ──────────────────────────────────────────

    /// Look up the C++ type for a runtime param by scanning the graph for actor
    /// nodes that reference `$param_name`, then finding the corresponding
    /// RUNTIME_PARAM type in the actor registry at the matching argument position.
    fn param_cpp_type(&self, param_name: &str, fallback: &Scalar) -> &'static str {
        // Search all task graphs for actor nodes that use ParamRef(param_name)
        for task_graph in self.graph.tasks.values() {
            for sub in subgraphs_of(task_graph) {
                for node in &sub.nodes {
                    if let NodeKind::Actor { name, args, .. } = &node.kind {
                        for (i, arg) in args.iter().enumerate() {
                            if let Arg::ParamRef(ident) = arg {
                                if ident.name == param_name {
                                    // Found the actor+position; look up type in registry
                                    if let Some(meta) = self.registry.lookup(name) {
                                        if let Some(p) = meta.params.get(i) {
                                            return match p.param_type {
                                                ParamType::Int => "int",
                                                ParamType::Float => "float",
                                                ParamType::Double => "double",
                                                _ => self.scalar_cpp_type(fallback),
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        self.scalar_cpp_type(fallback)
    }

    fn emit_param_storage(&mut self) {
        let mut has_any = false;
        for stmt in &self.program.statements {
            if let StatementKind::Param(p) = &stmt.kind {
                has_any = true;
                let cpp_type = self.param_cpp_type(&p.name.name, &p.value);
                let init = self.scalar_literal(&p.value);
                let _ = writeln!(
                    self.out,
                    "static std::atomic<{}> _param_{}({});",
                    cpp_type, p.name.name, init
                );
            }
        }
        if has_any {
            self.out.push('\n');
        }
    }

    // ── Phase 4: Shared (inter-task) buffers ────────────────────────────

    fn emit_shared_buffers(&mut self) {
        if self.resolved.buffers.is_empty() {
            return;
        }

        for buf_name in self.resolved.buffers.keys() {
            let wire_type = self.infer_buffer_wire_type(buf_name);
            let cpp_type = pipit_type_to_cpp(wire_type);
            let capacity = self.inter_task_buffer_capacity(buf_name, wire_type);
            let reader_count = self.buffer_reader_tasks(buf_name).len().max(1);
            let _ = writeln!(
                self.out,
                "static pipit::RingBuffer<{}, {}, {}> _ringbuf_{};",
                cpp_type, capacity, reader_count, buf_name
            );
        }
        self.out.push('\n');
    }

    // ── Phase 5: Stop flag ──────────────────────────────────────────────

    fn emit_stop_flag(&mut self) {
        self.out
            .push_str("static std::atomic<bool> _stop{false};\n");
        self.out
            .push_str("static std::atomic<int> _exit_code{0};\n\n");
    }

    // ── Phase 5b: Statistics and probe storage ────────────────────────────

    fn emit_stats_storage(&mut self) {
        self.out.push_str("static bool _stats = false;\n");

        let mut task_names: Vec<&String> = self.schedule.tasks.keys().collect();
        task_names.sort();
        for name in &task_names {
            let _ = writeln!(self.out, "static pipit::TaskStats _stats_{};", name);
        }

        // Probe flags and output
        if !self.resolved.probes.is_empty() && !self.options.release {
            self.out
                .push_str("static FILE* _probe_output_file = stderr;\n");
            for probe in &self.resolved.probes {
                let _ = writeln!(
                    self.out,
                    "static bool _probe_{}_enabled = false;",
                    probe.name
                );
            }
        }
        self.out.push('\n');
    }

    // ── Phase 6: Task functions ─────────────────────────────────────────

    fn emit_task_functions(&mut self) {
        // Sort task names for deterministic output
        let mut task_names: Vec<&String> = self.schedule.tasks.keys().collect();
        task_names.sort();

        for task_name in task_names {
            let meta = &self.schedule.tasks[task_name];
            let task_graph = self.graph.tasks.get(task_name.as_str());
            if task_graph.is_none() {
                continue;
            }
            let task_graph = task_graph.unwrap();

            let _ = writeln!(self.out, "void task_{}() {{", task_name);

            // Timer
            let _ = writeln!(
                self.out,
                "    pipit::Timer _timer({:.1});",
                meta.freq_hz / meta.k_factor as f64
            );

            // Feedback back-edge buffers (persist across K-loop iterations)
            self.emit_feedback_buffers(task_name, task_graph, &meta.schedule);

            // Main loop
            self.out
                .push_str("    while (!_stop.load(std::memory_order_acquire)) {\n");
            self.out.push_str("        _timer.wait();\n");

            // Overrun policy + stats
            let policy = self.get_overrun_policy().to_string();
            match policy.as_str() {
                "drop" => {
                    let _ = writeln!(
                        self.out,
                        "        if (_timer.overrun()) {{ if (_stats) _stats_{}.record_miss(); continue; }}",
                        task_name
                    );
                }
                "slip" => {
                    self.out
                        .push_str("        if (_timer.overrun()) _timer.reset_phase();\n");
                }
                "backlog" => {
                    self.out
                        .push_str("        int _backlog = _timer.overrun() ? static_cast<int>(_timer.missed_count()) : 0;\n");
                    self.out
                        .push_str("        for (int _bl = 0; _bl <= _backlog; ++_bl) {\n");
                }
                _ => {}
            }
            let _ = writeln!(
                self.out,
                "        if (_stats) _stats_{}.record_tick(_timer.last_latency());",
                task_name
            );

            // Read runtime params used by this task
            self.emit_param_reads(task_name, task_graph);

            // K-loop
            if meta.k_factor > 1 {
                let _ = writeln!(
                    self.out,
                    "        for (int _k = 0; _k < {}; ++_k) {{",
                    meta.k_factor
                );
            }

            let indent = if meta.k_factor > 1 {
                "            "
            } else {
                "        "
            };

            match &meta.schedule {
                TaskSchedule::Pipeline(sched) => {
                    let sub = match task_graph {
                        TaskGraph::Pipeline(s) => s,
                        _ => continue,
                    };
                    self.emit_subgraph_firings(task_name, "pipeline", sub, sched, indent);
                }
                TaskSchedule::Modal { control, modes } => {
                    let (ctrl_sub, mode_subs) = match task_graph {
                        TaskGraph::Modal {
                            control: c,
                            modes: m,
                        } => (c, m),
                        _ => continue,
                    };

                    // Control subgraph
                    let _ = writeln!(self.out, "{}// Control subgraph", indent);
                    self.emit_subgraph_firings(task_name, "control", ctrl_sub, control, indent);

                    // Read ctrl value from last BufferWrite in control
                    let ctrl_var = self.find_ctrl_output(ctrl_sub);
                    let _ = writeln!(self.out, "{}int32_t _ctrl = {};", indent, ctrl_var);

                    // Mode dispatch
                    let _ = writeln!(self.out, "{}switch (_ctrl) {{", indent);
                    for (i, (mode_name, mode_sched)) in modes.iter().enumerate() {
                        let _ = writeln!(self.out, "{}case {}: {{", indent, i);
                        let mode_sub = mode_subs.iter().find(|(n, _)| n == mode_name);
                        if let Some((_, sub)) = mode_sub {
                            self.emit_subgraph_firings(
                                task_name,
                                mode_name,
                                sub,
                                mode_sched,
                                &format!("{}    ", indent),
                            );
                        }
                        let _ = writeln!(self.out, "{}    break;", indent);
                        let _ = writeln!(self.out, "{}}}", indent);
                    }
                    let _ = writeln!(self.out, "{}default: break;", indent);
                    let _ = writeln!(self.out, "{}}}", indent);
                }
            }

            if meta.k_factor > 1 {
                self.out.push_str("        }\n");
            }

            // Close backlog loop if applicable
            if policy == "backlog" {
                self.out.push_str("        }\n");
            }

            self.out.push_str("    }\n");
            self.out.push_str("}\n\n");
        }
    }

    // ── Subgraph firing sequence ────────────────────────────────────────

    fn emit_subgraph_firings(
        &mut self,
        task_name: &str,
        label: &str,
        sub: &Subgraph,
        sched: &SubgraphSchedule,
        indent: &str,
    ) {
        // Declare intra-task edge buffers
        let edge_bufs = self.declare_edge_buffers(task_name, label, sub, sched, indent);

        // Emit each firing in topological order
        for entry in &sched.firings {
            let node = match find_node(sub, entry.node_id) {
                Some(n) => n,
                None => continue,
            };
            self.emit_firing(
                task_name, label, sub, sched, node, entry, indent, &edge_bufs,
            );
        }
    }

    fn declare_edge_buffers(
        &mut self,
        task_name: &str,
        _label: &str,
        sub: &Subgraph,
        sched: &SubgraphSchedule,
        indent: &str,
    ) -> HashMap<(NodeId, NodeId), String> {
        let mut names = HashMap::new();

        // Identify back-edges (feedback) — these are declared outside the K-loop
        let back_edges = self.identify_back_edges(task_name, sub);

        // Build alias map: Fork/Probe outgoing edges share the incoming edge's buffer.
        // Since scheduling is sequential within a task, no concurrent access occurs,
        // so downstream actors can safely read the upstream buffer directly.
        let aliases = self.build_passthrough_aliases(sub);

        // Pass 1: Declare real (non-aliased) buffers
        for (&(src, tgt), &tokens) in &sched.edge_buffers {
            if back_edges.contains(&(src, tgt)) {
                let var_name = format!("_fb_{}_{}", src.0, tgt.0);
                names.insert((src, tgt), var_name);
                continue;
            }

            // Skip aliased edges — they'll be resolved in pass 2
            if aliases.contains_key(&(src, tgt)) {
                continue;
            }

            let wire_type = self.infer_edge_wire_type(sub, src);
            let cpp_type = pipit_type_to_cpp(wire_type);
            let var_name = format!("_e{}_{}", src.0, tgt.0);
            let _ = writeln!(self.out, "{}{} {}[{}];", indent, cpp_type, var_name, tokens);
            names.insert((src, tgt), var_name);
        }

        // Pass 2: Resolve aliases (now all source buffers are named)
        for (&(src, tgt), &(alias_src, alias_tgt)) in &aliases {
            if let Some(alias_name) = names.get(&(alias_src, alias_tgt)) {
                names.insert((src, tgt), alias_name.clone());
            }
        }

        names
    }

    /// For Fork and Probe nodes, map each outgoing edge to the node's incoming edge.
    /// This allows downstream actors to read from the upstream buffer directly,
    /// eliminating memcpy for passthrough nodes.
    fn build_passthrough_aliases(
        &self,
        sub: &Subgraph,
    ) -> HashMap<(NodeId, NodeId), (NodeId, NodeId)> {
        let mut aliases = HashMap::new();

        for node in &sub.nodes {
            let is_passthrough =
                matches!(node.kind, NodeKind::Fork { .. } | NodeKind::Probe { .. });
            if !is_passthrough {
                continue;
            }

            // Find the single incoming edge
            let incoming: Vec<&Edge> = sub.edges.iter().filter(|e| e.target == node.id).collect();
            if let Some(in_edge) = incoming.first() {
                let src_key = (in_edge.source, in_edge.target);
                // All outgoing edges alias to this incoming edge
                for out_edge in sub.edges.iter().filter(|e| e.source == node.id) {
                    aliases.insert((out_edge.source, out_edge.target), src_key);
                }
            }
        }

        // Resolve transitive aliases (e.g., Probe feeding into Fork)
        let mut changed = true;
        while changed {
            changed = false;
            let snapshot: Vec<_> = aliases.iter().map(|(&k, &v)| (k, v)).collect();
            for (key, target) in snapshot {
                if let Some(&deeper) = aliases.get(&target) {
                    if deeper != target {
                        aliases.insert(key, deeper);
                        changed = true;
                    }
                }
            }
        }

        aliases
    }

    #[allow(clippy::too_many_arguments)]
    fn emit_firing(
        &mut self,
        task_name: &str,
        _label: &str,
        sub: &Subgraph,
        sched: &SubgraphSchedule,
        node: &Node,
        entry: &FiringEntry,
        indent: &str,
        edge_bufs: &HashMap<(NodeId, NodeId), String>,
    ) {
        // Fork/Probe are zero-copy passthrough nodes — no loop needed
        let is_passthrough = matches!(node.kind, NodeKind::Fork { .. } | NodeKind::Probe { .. });

        let rep = entry.repetition_count;
        let use_loop = rep > 1 && !is_passthrough;
        let inner_indent;
        let ind;

        if use_loop {
            let _ = writeln!(
                self.out,
                "{}for (int _r = 0; _r < {}; ++_r) {{",
                indent, rep
            );
            inner_indent = format!("{}    ", indent);
            ind = inner_indent.as_str();
        } else {
            ind = indent;
        }

        match &node.kind {
            NodeKind::Actor {
                name,
                args,
                shape_constraint,
                ..
            } => {
                // Use explicit shape constraint, or inferred from analysis
                let effective_sc = shape_constraint
                    .as_ref()
                    .or_else(|| self.analysis.inferred_shapes.get(&node.id));
                self.emit_actor_firing(
                    task_name,
                    sub,
                    sched,
                    node,
                    name,
                    args,
                    effective_sc,
                    ind,
                    edge_bufs,
                );
            }
            NodeKind::Fork { .. } => {
                self.emit_fork(sub, sched, node, ind, edge_bufs);
            }
            NodeKind::Probe { probe_name } => {
                self.emit_probe(sub, sched, node, probe_name, ind, edge_bufs);
            }
            NodeKind::BufferRead { buffer_name } => {
                self.emit_buffer_read(task_name, sub, sched, node, buffer_name, ind, edge_bufs);
            }
            NodeKind::BufferWrite { buffer_name } => {
                self.emit_buffer_write(task_name, sub, sched, node, buffer_name, ind, edge_bufs);
            }
        }

        if use_loop {
            let _ = writeln!(self.out, "{}}}", indent);
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn emit_actor_firing(
        &mut self,
        task_name: &str,
        sub: &Subgraph,
        sched: &SubgraphSchedule,
        node: &Node,
        actor_name: &str,
        args: &[Arg],
        shape_constraint: Option<&ShapeConstraint>,
        indent: &str,
        edge_bufs: &HashMap<(NodeId, NodeId), String>,
    ) {
        let meta = self.registry.lookup(actor_name);
        if meta.is_none() {
            return;
        }
        let meta = meta.unwrap();

        let in_count = self
            .resolve_port_rate_val(&meta.in_shape, meta, args, shape_constraint)
            .unwrap_or(0);
        let out_count = self
            .resolve_port_rate_val(&meta.out_shape, meta, args, shape_constraint)
            .unwrap_or(0);
        let in_cpp = pipit_type_to_cpp(meta.in_type);
        let _out_cpp = pipit_type_to_cpp(meta.out_type);

        // Input: find upstream edge buffers
        let incoming_edges: Vec<&Edge> = sub.edges.iter().filter(|e| e.target == node.id).collect();

        let in_ptr =
            if meta.in_type == PipitType::Void || in_count == 0 || incoming_edges.is_empty() {
                "nullptr".to_string()
            } else if incoming_edges.len() == 1 {
                let edge = incoming_edges[0];
                if let Some(buf_name) = edge_bufs.get(&(edge.source, edge.target)) {
                    let rep = self.firing_repetition(sched, node.id);
                    if rep > 1 {
                        format!("&{}[_r * {}]", buf_name, in_count)
                    } else {
                        buf_name.clone()
                    }
                } else {
                    "nullptr".to_string()
                }
            } else {
                // Multi-input actor: concatenate into a local buffer
                let local_in = format!("_in_{}", node.id.0);
                let _ = writeln!(self.out, "{}{} {}[{}];", indent, in_cpp, local_in, in_count);
                let mut offset = 0u32;
                let per_edge = in_count / incoming_edges.len() as u32;
                for edge in &incoming_edges {
                    if let Some(buf_name) = edge_bufs.get(&(edge.source, edge.target)) {
                        let rep = self.firing_repetition(sched, node.id);
                        let src_expr = if rep > 1 {
                            format!("&{}[_r * {}]", buf_name, per_edge)
                        } else {
                            buf_name.clone()
                        };
                        let _ = writeln!(
                            self.out,
                            "{}std::memcpy(&{}[{}], {}, {} * sizeof({}));",
                            indent, local_in, offset, src_expr, per_edge, in_cpp
                        );
                    }
                    offset += per_edge;
                }
                local_in
            };

        // Output buffer
        let outgoing_edges: Vec<&Edge> = sub.edges.iter().filter(|e| e.source == node.id).collect();

        let out_ptr =
            if meta.out_type == PipitType::Void || out_count == 0 || outgoing_edges.is_empty() {
                "nullptr".to_string()
            } else if outgoing_edges.len() == 1 {
                let edge = outgoing_edges[0];
                if let Some(buf_name) = edge_bufs.get(&(edge.source, edge.target)) {
                    let rep = self.firing_repetition(sched, node.id);
                    if rep > 1 {
                        format!("&{}[_r * {}]", buf_name, out_count)
                    } else {
                        buf_name.clone()
                    }
                } else {
                    "nullptr".to_string()
                }
            } else {
                // Multiple outgoing edges: write to first, then copy to rest (handled by fork)
                if let Some(buf_name) =
                    edge_bufs.get(&(outgoing_edges[0].source, outgoing_edges[0].target))
                {
                    let rep = self.firing_repetition(sched, node.id);
                    if rep > 1 {
                        format!("&{}[_r * {}]", buf_name, out_count)
                    } else {
                        buf_name.clone()
                    }
                } else {
                    "nullptr".to_string()
                }
            };

        // Construct actor and fire, check return value
        let params = self.format_actor_params(task_name, meta, args, shape_constraint);
        let call = if params.is_empty() {
            format!("Actor_{}{{}}({}, {})", actor_name, in_ptr, out_ptr)
        } else {
            format!(
                "Actor_{}{{{}}}.operator()({}, {})",
                actor_name, params, in_ptr, out_ptr
            )
        };
        let _ = writeln!(self.out, "{}if ({} != ACTOR_OK) {{", indent, call);
        let _ = writeln!(
            self.out,
            "{}    fprintf(stderr, \"runtime error: actor '{}' in task '{}' returned ACTOR_ERROR\\n\");",
            indent, actor_name, task_name
        );
        let _ = writeln!(
            self.out,
            "{}    _exit_code.store(1, std::memory_order_release);",
            indent
        );
        let _ = writeln!(
            self.out,
            "{}    _stop.store(true, std::memory_order_release);",
            indent
        );
        let _ = writeln!(self.out, "{}    return;", indent);
        let _ = writeln!(self.out, "{}}}", indent);
    }

    fn emit_fork(
        &mut self,
        _sub: &Subgraph,
        _sched: &SubgraphSchedule,
        node: &Node,
        indent: &str,
        _edge_bufs: &HashMap<(NodeId, NodeId), String>,
    ) {
        // Fork is a no-op: downstream actors share the upstream buffer directly
        // (aliased in declare_edge_buffers via build_passthrough_aliases)
        if let NodeKind::Fork { tap_name } = &node.kind {
            let _ = writeln!(self.out, "{}// fork: {} (zero-copy)", indent, tap_name);
        }
    }

    fn emit_probe(
        &mut self,
        sub: &Subgraph,
        sched: &SubgraphSchedule,
        node: &Node,
        probe_name: &str,
        indent: &str,
        edge_bufs: &HashMap<(NodeId, NodeId), String>,
    ) {
        // Probe is a no-op for data flow: downstream shares the upstream buffer.
        // Observation hook emits actual data when probe is enabled (stripped in release).
        if !self.options.release {
            let incoming: Vec<&Edge> = sub.edges.iter().filter(|e| e.target == node.id).collect();
            if let Some(in_edge) = incoming.first() {
                if let Some(src_buf) = edge_bufs.get(&(in_edge.source, in_edge.target)) {
                    let wire_type = self.infer_edge_wire_type(sub, in_edge.source);
                    let cpp_type = pipit_type_to_cpp(wire_type);
                    let count = self.edge_buffer_tokens(sched, in_edge.source, in_edge.target);
                    let fmt_spec = match cpp_type {
                        "float" | "double" => "%f",
                        "int32_t" | "int16_t" | "int8_t" => "%d",
                        _ => "%f", // cfloat/cdouble: print real part
                    };
                    let _ = writeln!(self.out, "{}#ifndef NDEBUG", indent);
                    let _ = writeln!(self.out, "{}if (_probe_{}_enabled) {{", indent, probe_name);
                    let _ = writeln!(
                        self.out,
                        "{}    for (int _pi = 0; _pi < {}; ++_pi)",
                        indent, count
                    );
                    let _ = writeln!(
                        self.out,
                        "{}        fprintf(_probe_output_file, \"[probe:{}] {}\\n\", {}[_pi]);",
                        indent, probe_name, fmt_spec, src_buf
                    );
                    let _ = writeln!(self.out, "{}    fflush(_probe_output_file);", indent);
                    let _ = writeln!(self.out, "{}}}", indent);
                    let _ = writeln!(self.out, "{}#endif", indent);
                }
            }
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn emit_buffer_read(
        &mut self,
        task_name: &str,
        sub: &Subgraph,
        sched: &SubgraphSchedule,
        node: &Node,
        buffer_name: &str,
        indent: &str,
        edge_bufs: &HashMap<(NodeId, NodeId), String>,
    ) {
        // Read from inter-task ring buffer into outgoing edge buffer
        let outgoing: Vec<&Edge> = sub.edges.iter().filter(|e| e.source == node.id).collect();

        if let Some(out_edge) = outgoing.first() {
            if let Some(dst_buf) = edge_bufs.get(&(out_edge.source, out_edge.target)) {
                let rep = self.firing_repetition(sched, node.id).max(1);
                let total_tokens = self.edge_buffer_tokens(sched, out_edge.source, out_edge.target);
                let per_firing_tokens = (total_tokens / rep).max(1);
                let dst_expr = if rep > 1 {
                    format!("&{}[_r * {}]", dst_buf, per_firing_tokens)
                } else {
                    dst_buf.clone()
                };
                let reader_idx = self
                    .reader_index_for_task(buffer_name, task_name)
                    .unwrap_or(0);
                let _ = writeln!(
                    self.out,
                    "{}if (!_ringbuf_{}.read({}, {}, {})) {{",
                    indent, buffer_name, reader_idx, dst_expr, per_firing_tokens
                );
                let _ = writeln!(
                    self.out,
                    "{}    std::fprintf(stderr, \"runtime error: task '{}' failed to read {} token(s) from shared buffer '{}'\\n\");",
                    indent, task_name, per_firing_tokens, buffer_name
                );
                let _ = writeln!(
                    self.out,
                    "{}    _stop.store(true, std::memory_order_release);",
                    indent
                );
                let _ = writeln!(self.out, "{}    return;", indent);
                let _ = writeln!(self.out, "{}}}", indent);
            }
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn emit_buffer_write(
        &mut self,
        task_name: &str,
        sub: &Subgraph,
        sched: &SubgraphSchedule,
        node: &Node,
        buffer_name: &str,
        indent: &str,
        edge_bufs: &HashMap<(NodeId, NodeId), String>,
    ) {
        // Write from incoming edge buffer to inter-task ring buffer
        let incoming: Vec<&Edge> = sub.edges.iter().filter(|e| e.target == node.id).collect();

        if let Some(in_edge) = incoming.first() {
            if let Some(src_buf) = edge_bufs.get(&(in_edge.source, in_edge.target)) {
                let rep = self.firing_repetition(sched, node.id).max(1);
                let total_tokens = self.edge_buffer_tokens(sched, in_edge.source, in_edge.target);
                let per_firing_tokens = (total_tokens / rep).max(1);
                let src_expr = if rep > 1 {
                    format!("&{}[_r * {}]", src_buf, per_firing_tokens)
                } else {
                    src_buf.clone()
                };
                let _ = writeln!(
                    self.out,
                    "{}if (!_ringbuf_{}.write({}, {})) {{",
                    indent, buffer_name, src_expr, per_firing_tokens
                );
                let _ = writeln!(
                    self.out,
                    "{}    std::fprintf(stderr, \"runtime error: task '{}' failed to write {} token(s) to shared buffer '{}'\\n\");",
                    indent, task_name, per_firing_tokens, buffer_name
                );
                let _ = writeln!(
                    self.out,
                    "{}    _stop.store(true, std::memory_order_release);",
                    indent
                );
                let _ = writeln!(self.out, "{}    return;", indent);
                let _ = writeln!(self.out, "{}}}", indent);
            }
        }
    }

    // ── Feedback buffer handling ────────────────────────────────────────

    fn emit_feedback_buffers(
        &mut self,
        task_name: &str,
        task_graph: &TaskGraph,
        task_schedule: &TaskSchedule,
    ) {
        let subs_and_scheds: Vec<(&Subgraph, &SubgraphSchedule)> = match (task_graph, task_schedule)
        {
            (TaskGraph::Pipeline(sub), TaskSchedule::Pipeline(sched)) => vec![(sub, sched)],
            (
                TaskGraph::Modal { control, modes },
                TaskSchedule::Modal {
                    control: ctrl_sched,
                    modes: mode_scheds,
                },
            ) => {
                let mut v: Vec<(&Subgraph, &SubgraphSchedule)> = vec![(control, ctrl_sched)];
                for (name, sched) in mode_scheds {
                    if let Some((_, sub)) = modes.iter().find(|(n, _)| n == name) {
                        v.push((sub, sched));
                    }
                }
                v
            }
            _ => vec![],
        };

        for (sub, sched) in subs_and_scheds {
            let back_edges = self.identify_back_edges(task_name, sub);
            for (src, tgt) in &back_edges {
                let tokens = sched.edge_buffers.get(&(*src, *tgt)).copied().unwrap_or(1);
                let wire_type = self.infer_edge_wire_type(sub, *src);
                let cpp_type = pipit_type_to_cpp(wire_type);

                // Get initial value from delay actor
                let init_val = self.delay_init_value(sub, *src);
                let var_name = format!("_fb_{}_{}", src.0, tgt.0);

                // Always declare as array for consistent pointer semantics
                let _ = writeln!(
                    self.out,
                    "    {} {}[{}] = {{{}}};",
                    cpp_type, var_name, tokens, init_val
                );
            }
        }
    }

    fn identify_back_edges(&self, _task_name: &str, sub: &Subgraph) -> HashSet<(NodeId, NodeId)> {
        let mut back_edges = HashSet::new();
        let node_ids: HashSet<u32> = sub.nodes.iter().map(|n| n.id.0).collect();

        for cycle in &self.graph.cycles {
            if !cycle.iter().all(|id| node_ids.contains(&id.0)) {
                continue;
            }
            for (i, &nid) in cycle.iter().enumerate() {
                if let Some(node) = find_node(sub, nid) {
                    if matches!(&node.kind, NodeKind::Actor { name, .. } if name == "delay") {
                        let next_nid = cycle[(i + 1) % cycle.len()];
                        if sub
                            .edges
                            .iter()
                            .any(|e| e.source == nid && e.target == next_nid)
                        {
                            back_edges.insert((nid, next_nid));
                        }
                        break;
                    }
                }
            }
        }
        back_edges
    }

    fn delay_init_value(&self, sub: &Subgraph, node_id: NodeId) -> String {
        if let Some(node) = find_node(sub, node_id) {
            if let NodeKind::Actor { args, name, .. } = &node.kind {
                if name == "delay" {
                    // Second arg is init value
                    if let Some(arg) = args.get(1) {
                        return self.arg_to_cpp_literal(arg);
                    }
                }
            }
        }
        "0".to_string()
    }

    // ── Runtime param reads ─────────────────────────────────────────────

    fn emit_param_reads(&mut self, _task_name: &str, task_graph: &TaskGraph) {
        let mut used_params: HashSet<String> = HashSet::new();
        self.collect_used_params(task_graph, &mut used_params);

        for param_name in &used_params {
            if let Some(entry) = self.resolved.params.get(param_name) {
                let stmt = &self.program.statements[entry.stmt_index];
                if let StatementKind::Param(p) = &stmt.kind {
                    let cpp_type = self.param_cpp_type(param_name, &p.value);
                    let _ = writeln!(
                        self.out,
                        "        {} _param_{}_val = _param_{}.load(std::memory_order_acquire);",
                        cpp_type, param_name, param_name
                    );
                }
            }
        }
    }

    fn collect_used_params(&self, task_graph: &TaskGraph, params: &mut HashSet<String>) {
        for sub in subgraphs_of(task_graph) {
            for node in &sub.nodes {
                if let NodeKind::Actor { args, .. } = &node.kind {
                    for arg in args {
                        if let Arg::ParamRef(ident) = arg {
                            params.insert(ident.name.clone());
                        }
                    }
                }
            }
        }
    }

    // ── Phase 7: main() ─────────────────────────────────────────────────

    fn emit_main(&mut self) {
        self.out.push_str("int main(int argc, char* argv[]) {\n");
        self.out
            .push_str("    double _duration_seconds = std::numeric_limits<double>::infinity();\n");
        self.out.push_str("    int _threads = 0;\n");
        self.out
            .push_str("    std::string _probe_output = \"stderr\";\n");
        self.out
            .push_str("    std::vector<std::string> _enabled_probes;\n");
        self.out.push('\n');

        // CLI argument parsing for runtime options.
        self.emit_runtime_cli_parsing();
        self.out.push('\n');

        // Probe initialization (validate and wire CLI args)
        self.emit_probe_initialization();

        // Signal handler
        self.out.push_str(
            "    std::signal(SIGINT, [](int) { _stop.store(true, std::memory_order_release); });\n",
        );
        self.out.push('\n');

        // Launch task threads
        let mut task_names: Vec<&String> = self.schedule.tasks.keys().collect();
        task_names.sort();
        for (i, name) in task_names.iter().enumerate() {
            let _ = writeln!(self.out, "    std::thread _t{}(task_{});", i, name);
        }
        self.out.push('\n');

        // Wait for stop signal (duration or SIGINT)
        self.emit_duration_wait();

        // Join all threads
        for i in 0..task_names.len() {
            let _ = writeln!(self.out, "    _t{}.join();", i);
        }
        self.out.push('\n');

        if task_names.len() > 1 {
            let _ = writeln!(
                self.out,
                "    if (_threads > 0 && _threads < {}) {{",
                task_names.len()
            );
            let _ = writeln!(
                self.out,
                "        std::fprintf(stderr, \"startup warning: --threads is advisory (requested=%d, tasks={})\\\\n\", _threads);",
                task_names.len()
            );
            self.out.push_str("    }\n");
            self.out.push('\n');
        }

        // Stats output
        self.emit_stats_output();

        self.out
            .push_str("    return _exit_code.load(std::memory_order_acquire);\n");
        self.out.push_str("}\n");
    }

    fn emit_stats_output(&mut self) {
        self.out.push_str("    if (_stats) {\n");

        let mut task_names: Vec<&String> = self.schedule.tasks.keys().collect();
        task_names.sort();
        let policy = self.get_overrun_policy().to_string();

        for name in &task_names {
            let _ = writeln!(
                self.out,
                "        fprintf(stderr, \"[stats] task '{}': ticks=%lu, missed=%lu ({}), max_latency=%ldns, avg_latency=%ldns\\n\",\n\
                             (unsigned long)_stats_{}.ticks, (unsigned long)_stats_{}.missed,\n\
                             _stats_{}.max_latency_ns, _stats_{}.avg_latency_ns());",
                name, policy, name, name, name, name
            );
        }

        // Shared buffer stats
        for buf_name in self.resolved.buffers.keys() {
            let wire_type = self.infer_buffer_wire_type(buf_name);
            let cpp_type = pipit_type_to_cpp(wire_type);
            let _ = writeln!(
                self.out,
                "        fprintf(stderr, \"[stats] shared buffer '{}': %zu tokens (%zuB)\\n\",\n\
                             (size_t)_ringbuf_{}.available(), _ringbuf_{}.available() * sizeof({}));",
                buf_name, buf_name, buf_name, cpp_type
            );
        }

        self.out.push_str("    }\n");
    }

    fn emit_runtime_cli_parsing(&mut self) {
        self.out.push_str(
            "    auto _parse_duration = [](const std::string& s, double* out) -> bool {\n",
        );
        self.out
            .push_str("        if (s == \"inf\") { *out = std::numeric_limits<double>::infinity(); return true; }\n");
        self.out.push_str("        std::size_t pos = 0;\n");
        self.out.push_str("        double base = 0.0;\n");
        self.out.push_str("        try {\n");
        self.out
            .push_str("            base = std::stod(s, &pos);\n");
        self.out.push_str("        } catch (...) {\n");
        self.out.push_str("            return false;\n");
        self.out.push_str("        }\n");
        self.out
            .push_str("        std::string unit = s.substr(pos);\n");
        self.out
            .push_str("        if (unit.empty() || unit == \"s\") { *out = base; return true; }\n");
        self.out
            .push_str("        if (unit == \"m\") { *out = base * 60.0; return true; }\n");
        self.out.push_str("        return false;\n");
        self.out.push_str("    };\n\n");

        self.out.push_str("    for (int i = 1; i < argc; ++i) {\n");
        self.out.push_str("        std::string opt(argv[i]);\n");
        self.out.push_str("        if (opt == \"--param\") {\n");
        self.out.push_str("            if (i + 1 >= argc) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --param requires name=value\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out
            .push_str("            std::string arg(argv[++i]);\n");
        self.out.push_str("            auto eq = arg.find('=');\n");
        self.out
            .push_str("            if (eq == std::string::npos) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --param requires name=value\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out
            .push_str("            auto name = arg.substr(0, eq);\n");
        self.out
            .push_str("            auto val = arg.substr(eq + 1);\n");

        let mut first = true;
        for (param_name, entry) in &self.resolved.params {
            let keyword = if first { "if" } else { "else if" };
            first = false;
            let stmt = &self.program.statements[entry.stmt_index];
            let converter = if let StatementKind::Param(p) = &stmt.kind {
                match self.param_cpp_type(param_name, &p.value) {
                    "int" => "std::stoi",
                    "double" => "std::stod",
                    _ => "std::stof",
                }
            } else {
                "std::stof"
            };
            let _ = writeln!(
                self.out,
                "            {} (name == \"{}\") _param_{}.store({}(val), std::memory_order_release);",
                keyword, param_name, param_name, converter
            );
        }

        if self.resolved.params.is_empty() {
            self.out.push_str(
                "            std::fprintf(stderr, \"startup error: --param is unsupported (no runtime params)\\\\n\");\n",
            );
            self.out.push_str("            return 2;\n");
        } else {
            self.out.push_str("            else {\n");
            self.out
                .push_str("                std::fprintf(stderr, \"startup error: unknown param '%s'\\\\n\", name.c_str());\n");
            self.out.push_str("                return 2;\n");
            self.out.push_str("            }\n");
        }

        self.out.push_str("            continue;\n");
        self.out.push_str("        }\n");

        self.out.push_str("        if (opt == \"--duration\") {\n");
        self.out.push_str("            if (i + 1 >= argc) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --duration requires a value\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out.push_str("            std::string d(argv[++i]);\n");
        self.out
            .push_str("            if (!_parse_duration(d, &_duration_seconds)) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: invalid --duration '%s' (use <sec>, <sec>s, <min>m, or inf)\\\\n\", d.c_str());\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out.push_str("            continue;\n");
        self.out.push_str("        }\n");

        self.out.push_str("        if (opt == \"--threads\") {\n");
        self.out.push_str("            if (i + 1 >= argc) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --threads requires a positive integer\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out.push_str("            try {\n");
        self.out
            .push_str("                _threads = std::stoi(std::string(argv[++i]));\n");
        self.out.push_str("            } catch (...) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --threads requires a positive integer\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out.push_str("            if (_threads <= 0) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --threads requires a positive integer\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out.push_str("            continue;\n");
        self.out.push_str("        }\n");

        self.out.push_str("        if (opt == \"--probe\") {\n");
        self.out.push_str("            if (i + 1 >= argc) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --probe requires a name\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out
            .push_str("            _enabled_probes.emplace_back(argv[++i]);\n");
        self.out.push_str("            continue;\n");
        self.out.push_str("        }\n");

        self.out
            .push_str("        if (opt == \"--probe-output\") {\n");
        self.out.push_str("            if (i + 1 >= argc) {\n");
        self.out
            .push_str("                std::fprintf(stderr, \"startup error: --probe-output requires a path\\\\n\");\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out
            .push_str("            _probe_output = std::string(argv[++i]);\n");
        self.out.push_str("            continue;\n");
        self.out.push_str("        }\n");

        self.out.push_str("        if (opt == \"--stats\") {\n");
        self.out.push_str("            _stats = true;\n");
        self.out.push_str("            continue;\n");
        self.out.push_str("        }\n");

        self.out.push_str(
            "        std::fprintf(stderr, \"startup error: unknown option '%s'\\\\n\", argv[i]);\n",
        );
        self.out.push_str("        return 2;\n");
        self.out.push_str("    }\n");
    }

    fn emit_probe_initialization(&mut self) {
        // Only emit probe initialization in debug builds
        if self.options.release || self.resolved.probes.is_empty() {
            return;
        }

        self.out.push_str("    // Probe initialization\n");
        self.out.push_str("    #ifndef NDEBUG\n");
        self.out
            .push_str("    if (!_enabled_probes.empty() || _probe_output != \"stderr\") {\n");

        // Build valid probe name set
        self.out
            .push_str("        std::unordered_set<std::string> _valid_probes = {");
        let mut first = true;
        for probe in &self.resolved.probes {
            if !first {
                self.out.push_str(", ");
            }
            first = false;
            let _ = write!(self.out, "\"{}\"", probe.name);
        }
        self.out.push_str("};\n");

        // Validate and enable probes
        self.out
            .push_str("        for (const auto& name : _enabled_probes) {\n");
        self.out
            .push_str("            if (_valid_probes.find(name) == _valid_probes.end()) {\n");
        self.out.push_str("                std::fprintf(stderr, \"startup error: unknown probe '%s'\\\\n\", name.c_str());\n");
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");

        // Enable specific probe flags
        for probe in &self.resolved.probes {
            let _ = writeln!(
                self.out,
                "            if (name == \"{}\") _probe_{}_enabled = true;",
                probe.name, probe.name
            );
        }

        self.out.push_str("        }\n");

        // Open probe output file if specified
        self.out
            .push_str("        if (_probe_output != \"stderr\") {\n");
        self.out.push_str(
            "            _probe_output_file = std::fopen(_probe_output.c_str(), \"w\");\n",
        );
        self.out
            .push_str("            if (!_probe_output_file) {\n");
        self.out.push_str("                std::fprintf(stderr, \"startup error: failed to open probe output file '%s': %s\\\\n\",\n");
        self.out.push_str(
            "                            _probe_output.c_str(), std::strerror(errno));\n",
        );
        self.out.push_str("                return 2;\n");
        self.out.push_str("            }\n");
        self.out.push_str("        }\n");

        self.out.push_str("    }\n");
        self.out.push_str("    #endif\n\n");
    }

    fn emit_duration_wait(&mut self) {
        self.out
            .push_str("    if (std::isfinite(_duration_seconds)) {\n");
        self.out.push_str(
            "        std::this_thread::sleep_for(std::chrono::duration<double>(_duration_seconds));\n",
        );
        self.out
            .push_str("        _stop.store(true, std::memory_order_release);\n");
        self.out.push_str("    } else {\n");
        self.out.push_str("        // Run until SIGINT\n");
        self.out
            .push_str("        while (!_stop.load(std::memory_order_acquire))\n");
        self.out
            .push_str("            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n");
        self.out.push_str("    }\n\n");
    }

    // ── Helpers ─────────────────────────────────────────────────────────

    fn get_set_ident<'b>(&'b self, name: &str) -> Option<&'b str> {
        for stmt in &self.program.statements {
            if let StatementKind::Set(set) = &stmt.kind {
                if set.name.name == name {
                    if let SetValue::Ident(ident) = &set.value {
                        return Some(&ident.name);
                    }
                }
            }
        }
        None
    }

    fn get_overrun_policy(&self) -> &str {
        match self.get_set_ident("overrun") {
            Some("drop") | Some("slip") | Some("backlog") => self.get_set_ident("overrun").unwrap(),
            _ => "drop",
        }
    }

    fn find_ctrl_output(&self, ctrl_sub: &Subgraph) -> String {
        // Find the last BufferWrite in the control subgraph; the data feeding it
        // is the ctrl value. We'll use the incoming edge buffer.
        for node in ctrl_sub.nodes.iter().rev() {
            if let NodeKind::BufferWrite { .. } = &node.kind {
                let incoming: Vec<&Edge> = ctrl_sub
                    .edges
                    .iter()
                    .filter(|e| e.target == node.id)
                    .collect();
                if let Some(edge) = incoming.first() {
                    return format!("_e{}_{}[0]", edge.source.0, edge.target.0);
                }
            }
        }
        "0".to_string()
    }

    fn scalar_literal(&self, scalar: &Scalar) -> String {
        match scalar {
            Scalar::Number(n, _) => {
                if *n == (*n as i64) as f64 && !n.is_nan() && !n.is_infinite() {
                    format!("{}", *n as i64)
                } else {
                    format!("{}f", n)
                }
            }
            Scalar::Freq(f, _) => format!("{:.1}", f),
            Scalar::Size(s, _) => format!("{}", s),
            Scalar::StringLit(s, _) => format!("\"{}\"", s),
            Scalar::Ident(ident) => format!("_const_{}", ident.name),
        }
    }

    fn scalar_cpp_type(&self, scalar: &Scalar) -> &'static str {
        match scalar {
            Scalar::Number(n, _) => {
                if *n == (*n as i64) as f64 && !n.is_nan() && !n.is_infinite() {
                    if *n >= i32::MIN as f64 && *n <= i32::MAX as f64 {
                        "int"
                    } else {
                        "double"
                    }
                } else {
                    "float"
                }
            }
            Scalar::Freq(_, _) => "double",
            Scalar::Size(_, _) => "size_t",
            Scalar::StringLit(_, _) => "const char*",
            Scalar::Ident(_) => "auto",
        }
    }

    fn infer_array_elem_type(&self, _elems: &[Scalar]) -> &'static str {
        // Const arrays in Pipit are coefficient arrays — always emit as float.
        // Integer-valued elements like [1.0, -1.0] are still float coefficients.
        "float"
    }

    fn format_actor_params(
        &self,
        _task_name: &str,
        meta: &ActorMeta,
        args: &[Arg],
        shape_constraint: Option<&ShapeConstraint>,
    ) -> String {
        let mut parts = Vec::new();
        // Track const array args used for count params so they can auto-fill span params.
        let mut last_array_const: Option<&Arg> = None;
        for (i, param) in meta.params.iter().enumerate() {
            if let Some(arg) = args.get(i) {
                match param.kind {
                    ParamKind::RuntimeParam => {
                        // Use the local cached value
                        if let Arg::ParamRef(ident) = arg {
                            parts.push(format!("_param_{}_val", ident.name));
                        } else {
                            parts.push(self.arg_to_cpp_literal(arg));
                        }
                        last_array_const = None;
                    }
                    ParamKind::Param => {
                        // If arg is a const array ref and param is int, remember it
                        if self.is_const_array_ref(arg) && param.param_type == ParamType::Int {
                            last_array_const = Some(arg);
                        } else {
                            last_array_const = None;
                        }
                        parts.push(self.arg_to_cpp_value(arg, &param.param_type));
                    }
                }
            } else if param.kind == ParamKind::Param {
                // No arg at this index — try to infer dimension param from shape constraint
                if let Some(val) =
                    self.resolve_dim_param_from_shape(&param.name, meta, shape_constraint)
                {
                    parts.push(val.to_string());
                } else if let Some(array_arg) = last_array_const {
                    // Auto-fill span param from prior array const
                    if matches!(param.param_type, ParamType::SpanFloat | ParamType::SpanChar) {
                        parts.push(self.arg_to_cpp_value(array_arg, &param.param_type));
                        last_array_const = None;
                    }
                }
            } else if let Some(array_arg) = last_array_const {
                // Auto-fill span param from prior array const (runtime param case)
                if matches!(param.param_type, ParamType::SpanFloat | ParamType::SpanChar) {
                    parts.push(self.arg_to_cpp_value(array_arg, &param.param_type));
                    last_array_const = None;
                }
            }
        }
        parts.join(", ")
    }

    /// Resolve a dimension parameter from shape constraints.
    /// Returns the inferred value if the param name appears in the actor's
    /// PortShape dims and can be resolved from the call-site shape constraint.
    fn resolve_dim_param_from_shape(
        &self,
        param_name: &str,
        meta: &ActorMeta,
        shape_constraint: Option<&ShapeConstraint>,
    ) -> Option<u32> {
        let sc = shape_constraint?;
        // Check in_shape dims for this param name
        for (i, dim) in meta.in_shape.dims.iter().enumerate() {
            if let TokenCount::Symbolic(sym) = dim {
                if sym == param_name {
                    return sc.dims.get(i).and_then(|sd| self.resolve_shape_dim(sd));
                }
            }
        }
        // Check out_shape dims
        for (i, dim) in meta.out_shape.dims.iter().enumerate() {
            if let TokenCount::Symbolic(sym) = dim {
                if sym == param_name {
                    return sc.dims.get(i).and_then(|sd| self.resolve_shape_dim(sd));
                }
            }
        }
        None
    }

    fn is_const_array_ref(&self, arg: &Arg) -> bool {
        if let Arg::ConstRef(ident) = arg {
            if let Some(entry) = self.resolved.consts.get(&ident.name) {
                let stmt = &self.program.statements[entry.stmt_index];
                if let StatementKind::Const(c) = &stmt.kind {
                    return matches!(&c.value, Value::Array(_, _));
                }
            }
        }
        false
    }

    fn arg_to_cpp_literal(&self, arg: &Arg) -> String {
        match arg {
            Arg::Value(Value::Scalar(s)) => self.scalar_literal(s),
            Arg::Value(Value::Array(_, _)) => "{}".to_string(),
            Arg::ParamRef(ident) => format!("_param_{}_val", ident.name),
            Arg::ConstRef(ident) => {
                // Resolve const value
                if let Some(entry) = self.resolved.consts.get(&ident.name) {
                    let stmt = &self.program.statements[entry.stmt_index];
                    if let StatementKind::Const(c) = &stmt.kind {
                        match &c.value {
                            Value::Scalar(s) => return self.scalar_literal(s),
                            Value::Array(_, _) => {
                                return format!("_const_{}", ident.name);
                            }
                        }
                    }
                }
                format!("_const_{}", ident.name)
            }
            Arg::TapRef(_) => "/* tap */".to_string(),
        }
    }

    fn arg_to_cpp_value(&self, arg: &Arg, param_type: &ParamType) -> String {
        match arg {
            Arg::Value(Value::Scalar(s)) => self.scalar_literal(s),
            Arg::Value(Value::Array(_, _)) => "{}".to_string(),
            Arg::ConstRef(ident) => {
                if let Some(entry) = self.resolved.consts.get(&ident.name) {
                    let stmt = &self.program.statements[entry.stmt_index];
                    if let StatementKind::Const(c) = &stmt.kind {
                        match &c.value {
                            Value::Scalar(s) => return self.scalar_literal(s),
                            Value::Array(elems, _) => {
                                // For span params, use std::span
                                if matches!(param_type, ParamType::SpanFloat | ParamType::SpanChar)
                                {
                                    return format!(
                                        "std::span<const float>(_const_{}, {})",
                                        ident.name,
                                        elems.len()
                                    );
                                }
                                return format!("{}", elems.len());
                            }
                        }
                    }
                }
                format!("_const_{}", ident.name)
            }
            Arg::ParamRef(ident) => format!("_param_{}_val", ident.name),
            Arg::TapRef(_) => "/* tap */".to_string(),
        }
    }

    fn infer_edge_wire_type(&self, sub: &Subgraph, src_id: NodeId) -> PipitType {
        // Trace from source node to find the wire type
        let mut current = src_id;
        let mut visited = HashSet::new();
        loop {
            if !visited.insert(current) {
                return PipitType::Float; // fallback
            }
            if let Some(node) = find_node(sub, current) {
                match &node.kind {
                    NodeKind::Actor { name, .. } => {
                        if let Some(meta) = self.registry.lookup(name) {
                            return meta.out_type;
                        }
                        return PipitType::Float;
                    }
                    NodeKind::BufferRead { buffer_name } => {
                        return self.infer_buffer_wire_type(buffer_name);
                    }
                    _ => {
                        // Passthrough: trace backward
                        if let Some(edge) = sub.edges.iter().find(|e| e.target == current) {
                            current = edge.source;
                        } else {
                            return PipitType::Float;
                        }
                    }
                }
            } else {
                return PipitType::Float;
            }
        }
    }

    fn infer_buffer_wire_type(&self, buffer_name: &str) -> PipitType {
        let buf_info = match self.resolved.buffers.get(buffer_name) {
            Some(b) => b,
            None => return PipitType::Float,
        };
        let task_graph = match self.graph.tasks.get(&buf_info.writer_task) {
            Some(g) => g,
            None => return PipitType::Float,
        };
        for sub in subgraphs_of(task_graph) {
            for node in &sub.nodes {
                if let NodeKind::BufferWrite {
                    buffer_name: name, ..
                } = &node.kind
                {
                    if name == buffer_name {
                        return self.infer_edge_wire_type(sub, node.id);
                    }
                }
            }
        }
        PipitType::Float
    }

    fn buffer_reader_tasks(&self, buffer_name: &str) -> Vec<String> {
        let mut readers = HashSet::new();
        if let Some(info) = self.resolved.buffers.get(buffer_name) {
            for (task_name, _) in &info.readers {
                readers.insert(task_name.clone());
            }
        }
        let mut sorted: Vec<String> = readers.into_iter().collect();
        sorted.sort();
        sorted
    }

    fn reader_index_for_task(&self, buffer_name: &str, task_name: &str) -> Option<usize> {
        self.buffer_reader_tasks(buffer_name)
            .iter()
            .position(|t| t == task_name)
    }

    fn inter_task_buffer_capacity(&self, buf_name: &str, wire_type: PipitType) -> u32 {
        let bytes = self
            .analysis
            .inter_task_buffers
            .get(buf_name)
            .copied()
            .unwrap_or(1024);
        let elem_size = pipit_type_size(wire_type);
        if elem_size == 0 {
            return 1024;
        }
        (bytes / elem_size as u64).max(1) as u32
    }

    /// Resolve a PortShape to a concrete rate (product of resolved dimensions).
    fn resolve_port_rate_val(
        &self,
        shape: &PortShape,
        actor_meta: &ActorMeta,
        actor_args: &[Arg],
        shape_constraint: Option<&ShapeConstraint>,
    ) -> Option<u32> {
        let mut product: u32 = 1;
        for (i, dim) in shape.dims.iter().enumerate() {
            let val = match dim {
                TokenCount::Literal(n) => Some(*n),
                TokenCount::Symbolic(sym) => {
                    let from_arg = actor_meta
                        .params
                        .iter()
                        .position(|p| p.name == *sym)
                        .and_then(|idx| actor_args.get(idx))
                        .and_then(|arg| self.resolve_arg_to_u32(arg));
                    if from_arg.is_some() {
                        from_arg
                    } else {
                        shape_constraint
                            .and_then(|sc| sc.dims.get(i))
                            .and_then(|sd| self.resolve_shape_dim(sd))
                    }
                }
            };
            product = product.checked_mul(val?)?;
        }
        Some(product)
    }

    fn resolve_shape_dim(&self, dim: &ShapeDim) -> Option<u32> {
        match dim {
            ShapeDim::Literal(n, _) => Some(*n),
            ShapeDim::ConstRef(ident) => {
                let entry = self.resolved.consts.get(&ident.name)?;
                let stmt = &self.program.statements[entry.stmt_index];
                if let StatementKind::Const(c) = &stmt.kind {
                    match &c.value {
                        Value::Scalar(Scalar::Number(n, _)) => Some(*n as u32),
                        _ => None,
                    }
                } else {
                    None
                }
            }
        }
    }

    fn resolve_arg_to_u32(&self, arg: &Arg) -> Option<u32> {
        match arg {
            Arg::Value(Value::Scalar(Scalar::Number(n, _))) => Some(*n as u32),
            Arg::Value(Value::Array(elems, _)) => Some(elems.len() as u32),
            Arg::ConstRef(ident) => {
                let entry = self.resolved.consts.get(&ident.name)?;
                let stmt = &self.program.statements[entry.stmt_index];
                if let StatementKind::Const(c) = &stmt.kind {
                    match &c.value {
                        Value::Scalar(Scalar::Number(n, _)) => Some(*n as u32),
                        Value::Array(elems, _) => Some(elems.len() as u32),
                        _ => None,
                    }
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    fn firing_repetition(&self, sched: &SubgraphSchedule, node_id: NodeId) -> u32 {
        sched
            .firings
            .iter()
            .find(|f| f.node_id == node_id)
            .map(|f| f.repetition_count)
            .unwrap_or(1)
    }

    fn edge_buffer_tokens(&self, sched: &SubgraphSchedule, src: NodeId, tgt: NodeId) -> u32 {
        sched.edge_buffers.get(&(src, tgt)).copied().unwrap_or(1)
    }
}

// ── Free helpers ────────────────────────────────────────────────────────────

fn find_node(sub: &Subgraph, id: NodeId) -> Option<&Node> {
    sub.nodes.iter().find(|n| n.id == id)
}

fn subgraphs_of(task_graph: &TaskGraph) -> Vec<&Subgraph> {
    match task_graph {
        TaskGraph::Pipeline(sub) => vec![sub],
        TaskGraph::Modal { control, modes } => {
            let mut subs = vec![control];
            for (_, sub) in modes {
                subs.push(sub);
            }
            subs
        }
    }
}

fn pipit_type_to_cpp(t: PipitType) -> &'static str {
    match t {
        PipitType::Float => "float",
        PipitType::Double => "double",
        PipitType::Int8 => "int8_t",
        PipitType::Int16 => "int16_t",
        PipitType::Int32 => "int32_t",
        PipitType::Cfloat => "cfloat",
        PipitType::Cdouble => "cdouble",
        PipitType::Void => "void",
    }
}

fn pipit_type_size(t: PipitType) -> usize {
    match t {
        PipitType::Int8 => 1,
        PipitType::Int16 => 2,
        PipitType::Int32 | PipitType::Float => 4,
        PipitType::Double => 8,
        PipitType::Cfloat => 8,
        PipitType::Cdouble => 16,
        PipitType::Void => 0,
    }
}

// ── Tests ───────────────────────────────────────────────────────────────────
// Unit tests: verify structural and semantic properties of generated C++ strings
// (firing order, buffer layout, probe stripping) without a C++ compiler.
// Complements compiler/tests/codegen_compile.rs (compilation + runtime checks).

#[cfg(test)]
mod tests {
    use super::*;
    use crate::registry::Registry;
    use crate::resolve::{self, DiagLevel};
    use std::path::PathBuf;

    fn test_registry() -> Registry {
        let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .to_path_buf();
        let std_actors = root.join("runtime/libpipit/include/std_actors.h");
        let example_actors = root.join("examples/example_actors.h");
        let mut reg = Registry::new();
        reg.load_header(&std_actors)
            .expect("failed to load std_actors.h");
        reg.load_header(&example_actors)
            .expect("failed to load example_actors.h");
        reg
    }

    fn codegen_source_with_options(
        source: &str,
        registry: &Registry,
        options: CodegenOptions,
    ) -> CodegenResult {
        let parse_result = crate::parser::parse(source);
        assert!(
            parse_result.errors.is_empty(),
            "parse errors: {:?}",
            parse_result.errors
        );
        let program = parse_result.program.expect("parse failed");
        let resolve_result = resolve::resolve(&program, registry);
        assert!(
            resolve_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "resolve errors: {:#?}",
            resolve_result.diagnostics
        );
        let graph_result = crate::graph::build_graph(&program, &resolve_result.resolved, registry);
        assert!(
            graph_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "graph errors: {:#?}",
            graph_result.diagnostics
        );
        let analysis_result = crate::analyze::analyze(
            &program,
            &resolve_result.resolved,
            &graph_result.graph,
            registry,
        );
        assert!(
            analysis_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "analysis errors: {:#?}",
            analysis_result.diagnostics
        );
        let schedule_result = crate::schedule::schedule(
            &program,
            &resolve_result.resolved,
            &graph_result.graph,
            &analysis_result.analysis,
            registry,
        );
        assert!(
            schedule_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "schedule errors: {:#?}",
            schedule_result.diagnostics
        );
        codegen(
            &program,
            &resolve_result.resolved,
            &graph_result.graph,
            &analysis_result.analysis,
            &schedule_result.schedule,
            registry,
            &options,
        )
    }

    fn codegen_source(source: &str, registry: &Registry) -> CodegenResult {
        codegen_source_with_options(
            source,
            registry,
            CodegenOptions {
                release: false,
                include_paths: vec![],
            },
        )
    }

    fn codegen_ok(source: &str, registry: &Registry) -> String {
        let result = codegen_source(source, registry);
        let errors: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| d.level == DiagLevel::Error)
            .collect();
        assert!(
            errors.is_empty(),
            "unexpected codegen errors: {:#?}",
            errors
        );
        result.generated.cpp_source
    }

    // ── Const emission tests ────────────────────────────────────────────

    #[test]
    fn const_array_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "const coeff = [0.1, 0.2, 0.4]\nclock 1kHz t { constant(0.0) | fir(coeff) | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("static constexpr float _const_coeff[]"),
            "should emit const array"
        );
        assert!(cpp.contains("0.1f"), "should have float literals");
    }

    #[test]
    fn const_scalar_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "const fft_size = 256\nclock 1kHz t { constant(0.0) | fft(fft_size) | c2r() | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("static constexpr auto _const_fft_size = 256;"),
            "should emit const scalar: {}",
            cpp
        );
    }

    // ── Param storage tests ─────────────────────────────────────────────

    #[test]
    fn param_storage_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "param gain = 2.5\nclock 1kHz t { constant(0.0) | mul($gain) | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("std::atomic<float> _param_gain(2.5f)"),
            "should emit param atomic: {}",
            cpp
        );
    }

    // ── Actor firing tests ──────────────────────────────────────────────

    #[test]
    fn source_actor_firing() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("Actor_constant"),
            "should fire constant actor: {}",
            cpp
        );
        assert!(
            cpp.contains("Actor_stdout"),
            "should fire stdout actor: {}",
            cpp
        );
        // Verify topological firing order
        let pos_const = cpp.find("Actor_constant").unwrap();
        let pos_stdout = cpp.find("Actor_stdout").unwrap();
        assert!(
            pos_const < pos_stdout,
            "constant must fire before stdout in schedule order"
        );
    }

    #[test]
    fn transform_actor_firing() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "clock 1kHz t { constant(0.0) | fft(256) | c2r() | stdout() }",
            &reg,
        );
        assert!(cpp.contains("Actor_fft"), "should fire fft actor: {}", cpp);
        assert!(cpp.contains("Actor_c2r"), "should fire c2r actor: {}", cpp);
        // Verify full topological firing order
        let pos_const = cpp.find("Actor_constant").unwrap();
        let pos_fft = cpp.find("Actor_fft").unwrap();
        let pos_c2r = cpp.find("Actor_c2r").unwrap();
        let pos_stdout = cpp.find("Actor_stdout").unwrap();
        assert!(pos_const < pos_fft, "constant must fire before fft");
        assert!(pos_fft < pos_c2r, "fft must fire before c2r");
        assert!(pos_c2r < pos_stdout, "c2r must fire before stdout");
    }

    #[test]
    fn repetition_offset_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "clock 1kHz t { constant(0.0) | fft(256) | c2r() | stdout() }",
            &reg,
        );
        // fft produces 256 tokens from 1 input; downstream actors repeat with _r offsets
        assert!(
            cpp.contains("for (int _r = 0; _r <"),
            "rate mismatch should produce _r repetition loop: {}",
            cpp
        );
        assert!(
            cpp.contains("_r *"),
            "repetition loop should use _r offset expressions: {}",
            cpp
        );
    }

    // ── Task structure tests ────────────────────────────────────────────

    #[test]
    fn task_function_structure() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("void task_t()"),
            "should emit task function: {}",
            cpp
        );
        assert!(cpp.contains("pipit::Timer"), "should have timer: {}", cpp);
        assert!(
            cpp.contains("_stop.load"),
            "should check stop flag: {}",
            cpp
        );
    }

    #[test]
    fn k_factor_loop() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 10MHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("for (int _k = 0; _k < 10; ++_k)"),
            "should have K-loop: {}",
            cpp
        );
        // Verify firing order within K-loop
        let pos_const = cpp.find("Actor_constant").unwrap();
        let pos_stdout = cpp.find("Actor_stdout").unwrap();
        assert!(
            pos_const < pos_stdout,
            "constant must fire before stdout within K-loop"
        );
    }

    // ── Fork test ───────────────────────────────────────────────────────

    #[test]
    fn fork_zero_copy() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "clock 1kHz t { constant(0.0) | :raw | stdout()\n:raw | stdout() }",
            &reg,
        );
        // Fork should NOT use memcpy — downstream actors share the upstream buffer
        assert!(
            !cpp.contains("memcpy"),
            "fork should be zero-copy (no memcpy): {}",
            cpp
        );
        assert!(cpp.contains("// fork:"), "fork comment expected: {}", cpp);
    }

    // ── Shared buffer test ──────────────────────────────────────────────

    #[test]
    fn shared_buffer_declaration() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "set mem = 64MB\n",
                "clock 1kHz a { constant(0.0) -> sig }\n",
                "clock 1kHz b { @sig | stdout() }\n",
            ),
            &reg,
        );
        assert!(
            cpp.contains("pipit::RingBuffer<float"),
            "should declare ring buffer: {}",
            cpp
        );
        assert!(cpp.contains("_ringbuf_sig"), "should name buffer: {}", cpp);
    }

    // ── Main function test ──────────────────────────────────────────────

    #[test]
    fn main_with_threads() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "set mem = 64MB\n",
                "clock 1kHz a { constant(0.0) -> sig }\n",
                "clock 1kHz b { @sig | stdout() }\n",
            ),
            &reg,
        );
        assert!(cpp.contains("int main("), "should have main: {}", cpp);
        assert!(cpp.contains("std::thread"), "should spawn threads: {}", cpp);
    }

    // ── Release mode tests ─────────────────────────────────────────────

    #[test]
    fn release_mode_strips_probes() {
        let reg = test_registry();
        let source = "clock 1kHz t { constant(0.0) | mul(1.0) | ?debug | stdout() }";

        // Debug mode: probe infrastructure present
        let debug_cpp = codegen_ok(source, &reg);
        assert!(
            debug_cpp.contains("#ifndef NDEBUG"),
            "debug build should contain #ifndef NDEBUG: {}",
            debug_cpp
        );
        assert!(
            debug_cpp.contains("_probe_debug_enabled"),
            "debug build should contain probe enable flag: {}",
            debug_cpp
        );

        // Release mode: probe infrastructure stripped
        let release_result = codegen_source_with_options(
            source,
            &reg,
            CodegenOptions {
                release: true,
                include_paths: vec![],
            },
        );
        let errors: Vec<_> = release_result
            .diagnostics
            .iter()
            .filter(|d| d.level == DiagLevel::Error)
            .collect();
        assert!(
            errors.is_empty(),
            "unexpected codegen errors: {:#?}",
            errors
        );
        let release_cpp = release_result.generated.cpp_source;

        assert!(
            !release_cpp.contains("#ifndef NDEBUG"),
            "release build should NOT contain #ifndef NDEBUG: {}",
            release_cpp
        );
        assert!(
            !release_cpp.contains("_probe_debug_enabled"),
            "release build should NOT contain probe enable flag: {}",
            release_cpp
        );
        assert!(
            !release_cpp.contains("[probe:"),
            "release build should NOT contain probe output formatting: {}",
            release_cpp
        );
    }

    // ── Integration tests ───────────────────────────────────────────────

    #[test]
    fn gain_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/gain.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read gain.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(cpp.contains("Actor_mul"), "gain.pdl should have mul");
        assert!(cpp.contains("_param_gain"), "gain.pdl should ref param");
    }

    #[test]
    fn example_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/example.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read example.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(
            cpp.contains("pipit::RingBuffer"),
            "example.pdl should have inter-task buffer"
        );
        assert!(
            cpp.contains("std::thread"),
            "example.pdl should have threads"
        );
    }

    #[test]
    fn receiver_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/receiver.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read receiver.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(
            cpp.contains("switch (_ctrl)"),
            "receiver.pdl should have mode switch: {}",
            cpp
        );
    }

    #[test]
    fn feedback_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/feedback.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read feedback.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(
            cpp.contains("_fb_"),
            "feedback.pdl should have feedback buffer: {}",
            cpp
        );
        assert!(
            cpp.contains("Actor_delay"),
            "feedback.pdl should have delay actor"
        );
    }
}
