// codegen.rs — C++ code generation for Pipit programs
//
// Transforms the scheduled SDF program into compilable C++ source code.
// Each task becomes a function with a timer loop, actor firing sequence,
// and intra-task edge buffers. Inter-task communication uses ring buffers.
//
// Preconditions: all upstream phases (parse, resolve, graph, analyze, schedule)
//                completed without errors.
// Postconditions: returns `CodegenResult` with generated C++ source string.
// Failure modes: missing actor metadata or unresolvable types produce diagnostics.
// Side effects: none.

use std::collections::HashMap;
use std::fmt::Write as _;
use std::path::PathBuf;

use crate::diag::Diagnostic;
use crate::graph::*;
use crate::lir::{
    LirActorArg, LirActorFiring, LirBufferIo, LirConstValue, LirCtrlSource, LirFiring,
    LirFiringGroup, LirFiringKind, LirFusedChain, LirHoistedActor, LirModalBody, LirProbeFiring,
    LirProgram, LirSubgraph, LirTaskBody, LirTimerSpin,
};
use crate::schedule::*;

// ── Public types ────────────────────────────────────────────────────────────

#[derive(Debug)]
pub struct CodegenResult {
    pub generated: GeneratedCode,
    pub diagnostics: Vec<Diagnostic>,
}

#[derive(Debug)]
pub struct GeneratedCode {
    pub cpp_source: String,
}

#[derive(Debug, Clone)]
pub struct CodegenOptions {
    pub release: bool,
    pub include_paths: Vec<PathBuf>,
    /// Provenance metadata to stamp in generated C++ header comment.
    /// None in unit tests; Some in production builds.
    pub provenance: Option<crate::pipeline::Provenance>,
}

// ── Public entry point ──────────────────────────────────────────────────────

/// Generate C++ code from a pre-built LIR program.
///
/// All type/rate/dimension resolution has been performed by the LIR builder,
/// so codegen is syntax-directed. The graph and schedule are still required
/// for task iteration structure.
pub fn codegen_from_lir(
    graph: &ProgramGraph,
    schedule: &ScheduledProgram,
    options: &CodegenOptions,
    lir: &LirProgram,
) -> CodegenResult {
    let mut ctx = CodegenCtx::new(graph, schedule, options, lir);
    ctx.emit_all();
    ctx.build_result()
}

// ── Internal context ────────────────────────────────────────────────────────

struct CodegenCtx<'a> {
    graph: &'a ProgramGraph,
    schedule: &'a ScheduledProgram,
    options: &'a CodegenOptions,
    lir: &'a LirProgram,
    out: String,
    diagnostics: Vec<Diagnostic>,
}

impl<'a> CodegenCtx<'a> {
    fn new(
        graph: &'a ProgramGraph,
        schedule: &'a ScheduledProgram,
        options: &'a CodegenOptions,
        lir: &'a LirProgram,
    ) -> Self {
        CodegenCtx {
            graph,
            schedule,
            options,
            lir,
            out: String::with_capacity(8192),
            diagnostics: Vec::new(),
        }
    }

    fn build_result(self) -> CodegenResult {
        CodegenResult {
            generated: GeneratedCode {
                cpp_source: self.out,
            },
            diagnostics: self.diagnostics,
        }
    }

    // ── Top-level emit ──────────────────────────────────────────────────

    fn emit_all(&mut self) {
        self.emit_preamble();
        self.emit_const_storage();
        self.emit_param_storage();
        self.emit_shared_buffers();
        self.emit_stop_flag();
        self.emit_stats_storage();
        self.emit_task_functions();
        self.emit_main();
    }

    // ── Phase 1: Preamble ───────────────────────────────────────────────

    fn emit_preamble(&mut self) {
        if let Some(ref prov) = self.options.provenance {
            let _ = writeln!(
                self.out,
                "// pcc provenance: source_hash={} registry_fingerprint={} version={}",
                prov.source_hash_hex(),
                prov.registry_fingerprint_hex(),
                prov.compiler_version,
            );
        }
        self.out
            .push_str("// Generated by pcc (Pipit Compiler Collection)\n");
        self.out.push_str("#include <pipit.h>\n");
        self.out.push_str("#include <pipit_shell.h>\n");
        self.out.push_str("#include <cstdio>\n");
        self.out.push('\n');

        for path in &self.options.include_paths {
            let escaped = path
                .to_string_lossy()
                .replace('\\', "\\\\")
                .replace('"', "\\\"");
            let _ = writeln!(self.out, "#include \"{}\"", escaped);
        }
        if !self.options.include_paths.is_empty() {
            self.out.push('\n');
        }
    }

    // ── Phase 2: Const storage ──────────────────────────────────────────

    fn emit_const_storage(&mut self) {
        let lir = self.lir;
        if lir.consts.is_empty() {
            return;
        }
        for c in &lir.consts {
            match &c.value {
                LirConstValue::Scalar { literal } => {
                    let _ = writeln!(
                        self.out,
                        "static constexpr auto _const_{} = {};",
                        c.name, literal
                    );
                }
                LirConstValue::Array {
                    elem_type,
                    elements,
                } => {
                    let _ = writeln!(
                        self.out,
                        "static constexpr {} _const_{}[] = {{{}}};",
                        elem_type,
                        c.name,
                        elements.join(", ")
                    );
                }
            }
        }
        self.out.push('\n');
    }

    // ── Phase 3: Param storage ──────────────────────────────────────────

    fn emit_param_storage(&mut self) {
        let lir = self.lir;
        if lir.params.is_empty() {
            return;
        }
        for p in &lir.params {
            let _ = writeln!(
                self.out,
                "static std::atomic<{}> _param_{}_write({});",
                p.cpp_type, p.name, p.default_literal
            );
            let _ = writeln!(
                self.out,
                "static std::atomic<{}> _param_{}_read({});",
                p.cpp_type, p.name, p.default_literal
            );
        }
        self.out.push('\n');
    }

    // ── Phase 4: Shared (inter-task) buffers ────────────────────────────

    fn emit_shared_buffers(&mut self) {
        let lir = self.lir;
        if lir.inter_task_buffers.is_empty() {
            return;
        }
        for buf in &lir.inter_task_buffers {
            let _ = writeln!(
                self.out,
                "static pipit::RingBuffer<{}, {}, {}> _ringbuf_{};",
                buf.cpp_type, buf.capacity_tokens, buf.reader_count, buf.name
            );
        }
        self.out.push('\n');
    }

    // ── Phase 5: Stop flag ──────────────────────────────────────────────

    fn emit_stop_flag(&mut self) {
        self.out
            .push_str("static std::atomic<bool> _stop{false};\n");
        self.out
            .push_str("static std::atomic<int> _exit_code{0};\n");
        self.out
            .push_str("static std::atomic<bool> _start{false};\n\n");
    }

    // ── Phase 5b: Statistics and probe storage ────────────────────────────

    fn emit_stats_storage(&mut self) {
        self.out.push_str("static bool _stats = false;\n");

        let lir = self.lir;
        for task in &lir.tasks {
            let _ = writeln!(self.out, "static pipit::TaskStats _stats_{};", task.name);
        }
        // _probe_output_file is always emitted (even in release) so the symbol
        // exists for RuntimeState::probe_output. Task functions' probe output
        // code (#ifndef NDEBUG) references this symbol — the C++ compiler strips
        // dead code but the symbol must exist for compilation.
        self.out
            .push_str("static FILE* _probe_output_file = nullptr;\n");
        if !lir.probes.is_empty() && !self.options.release {
            for probe in &lir.probes {
                let _ = writeln!(
                    self.out,
                    "static bool _probe_{}_enabled = false;",
                    probe.name
                );
            }
        }
        self.out.push('\n');
    }

    // ── Phase 6: Task functions ─────────────────────────────────────────

    fn emit_task_functions(&mut self) {
        for task_name in self.sorted_task_names() {
            let Some(task_graph) = self.graph.tasks.get(task_name.as_str()) else {
                continue;
            };
            self.emit_task_function(&task_name, task_graph);
        }
    }

    fn sorted_task_names(&self) -> Vec<String> {
        let mut task_names: Vec<String> = self.schedule.tasks.keys().cloned().collect();
        task_names.sort();
        task_names
    }

    fn emit_task_function(&mut self, task_name: &str, task_graph: &TaskGraph) {
        let Some(meta) = self.schedule.tasks.get(task_name) else {
            return;
        };
        let _ = writeln!(self.out, "void task_{}() {{", task_name);
        self.emit_task_prologue(task_name, meta, task_graph);
        self.out
            .push_str("    while (!_stop.load(std::memory_order_acquire)) {\n");
        self.out.push_str("        _timer.wait();\n");

        let policy = self.emit_task_overrun_policy(task_name);
        let tick_hoisted_actors = self.emit_tick_hoisted_actor_declarations(
            task_name,
            task_graph,
            &meta.schedule,
            "        ",
        );
        let indent =
            self.emit_task_iteration_setup(task_name, task_graph, meta.k_factor, &meta.schedule);
        self.emit_task_schedule_dispatch(
            task_name,
            task_graph,
            &meta.schedule,
            indent,
            &tick_hoisted_actors,
        );

        if meta.k_factor > 1 {
            self.out.push_str("        }\n");
        }
        if policy == "backlog" {
            self.out.push_str("        }\n");
        }
        self.out.push_str("    }\n");
        self.out.push_str("}\n\n");
    }

    fn emit_tick_hoisted_actor_declarations(
        &mut self,
        task_name: &str,
        _task_graph: &TaskGraph,
        _schedule: &TaskSchedule,
        indent: &str,
    ) -> HashMap<NodeId, String> {
        // LIR path: emit tick-level hoisted declarations from pre-resolved LIR data
        let lir = self.lir;
        if let Some(lir_task) = lir.tasks.iter().find(|t| t.name == task_name) {
            let hoisted_list = collect_lir_tick_hoistable_actors(&lir_task.body);
            let mut hoisted = HashMap::new();
            for (var_name, cpp_name, params) in &hoisted_list {
                let params_str = format_lir_actor_args(params);
                if params_str.is_empty() {
                    let _ = writeln!(self.out, "{}auto {} = {}{{}};", indent, var_name, cpp_name);
                } else {
                    let _ = writeln!(
                        self.out,
                        "{}auto {} = {}{{{}}};",
                        indent, var_name, cpp_name, params_str
                    );
                }
                if let Some(id_str) = var_name.strip_prefix("_actor_") {
                    if let Ok(id) = id_str.parse::<u32>() {
                        hoisted.insert(NodeId(id), var_name.clone());
                    }
                }
            }
            return hoisted;
        }

        HashMap::new()
    }

    fn emit_task_prologue(&mut self, task_name: &str, meta: &TaskMeta, task_graph: &TaskGraph) {
        // Wait for all task threads to be created before starting timer.
        self.out.push_str(
            "    while (!_start.load(std::memory_order_acquire)) { std::this_thread::yield(); }\n",
        );

        // Timer (measure_latency enabled only when stats are active;
        // spin_ns from `set timer_spin`, default 10us; `auto` = adaptive).
        let spin_ns = match self.lir.directives.timer_spin {
            LirTimerSpin::Fixed(ns) => ns,
            LirTimerSpin::Adaptive => -1,
        };
        let _ = writeln!(
            self.out,
            "    pipit::Timer _timer({:.1}, _stats, {});",
            meta.freq_hz / meta.k_factor as f64,
            spin_ns
        );
        let _ = writeln!(
            self.out,
            "    pipit::detail::set_actor_task_rate_hz({:.1});",
            meta.freq_hz
        );
        self.out.push_str("    uint64_t _iter_idx = 0;\n");

        // Feedback back-edge buffers (persist across K-loop iterations).
        self.emit_feedback_buffers(task_name, task_graph, &meta.schedule);
        if matches!(&meta.schedule, TaskSchedule::Modal { .. }) {
            self.out.push_str("    int32_t _active_mode = -1;\n");
        }
    }

    fn emit_task_overrun_policy(&mut self, task_name: &str) -> String {
        let policy = self.get_overrun_policy().to_string();
        match policy.as_str() {
            "drop" => {
                let _ = writeln!(
                    self.out,
                    "        if (_timer.overrun()) {{ if (_stats) _stats_{}.record_miss(); continue; }}",
                    task_name
                );
            }
            "slip" => {
                self.out
                    .push_str("        if (_timer.overrun()) _timer.reset_phase();\n");
            }
            "backlog" => {
                self.out.push_str(
                    "        int _backlog = _timer.overrun() ? static_cast<int>(_timer.missed_count()) : 0;\n",
                );
                self.out
                    .push_str("        for (int _bl = 0; _bl <= _backlog; ++_bl) {\n");
            }
            _ => {}
        }
        let _ = writeln!(
            self.out,
            "        if (_stats) _stats_{}.record_tick(_timer.last_latency());",
            task_name
        );
        policy
    }

    /// Compute the iteration stride for a task: total samples produced per PASS cycle.
    ///
    /// For pipeline tasks, this is the first actor's `out_rate × repetition_count`.
    /// Falls back to 1 for modal tasks or when rates are unavailable.
    fn iteration_stride(&self, task_name: &str) -> u32 {
        let lir_task = match self.lir.tasks.iter().find(|t| t.name == task_name) {
            Some(t) => t,
            None => return 1,
        };
        let sub = match &lir_task.body {
            LirTaskBody::Pipeline(sub) => sub,
            _ => return 1,
        };
        for group in &sub.firings {
            let firing = match group {
                LirFiringGroup::Single(f) => f,
                LirFiringGroup::Fused(chain) => match chain.body.first() {
                    Some(f) => f,
                    None => continue,
                },
            };
            if let LirFiringKind::Actor(actor) = &firing.kind {
                if let Some(r) = actor.out_rate {
                    if r > 0 {
                        return r * firing.repetition;
                    }
                }
            }
        }
        1
    }

    fn emit_task_iteration_setup(
        &mut self,
        task_name: &str,
        task_graph: &TaskGraph,
        k_factor: u32,
        _schedule: &TaskSchedule,
    ) -> &'static str {
        let stride = self.iteration_stride(task_name);
        let indent = if k_factor > 1 {
            let _ = writeln!(
                self.out,
                "        for (int _k = 0; _k < {}; ++_k) {{",
                k_factor
            );
            "            "
        } else {
            "        "
        };
        if stride <= 1 {
            // _iter_idx++ is post-increment: passes old value, then increments
            let _ = writeln!(
                self.out,
                "{}pipit::detail::set_actor_iteration_index(_iter_idx++);",
                indent
            );
        } else {
            // Set current index first, then advance — compound assignment
            // (_iter_idx += N) would pass the *new* value, skipping index 0.
            let _ = writeln!(
                self.out,
                "{}pipit::detail::set_actor_iteration_index(_iter_idx);",
                indent
            );
            let _ = writeln!(self.out, "{}_iter_idx += {};", indent, stride);
        }
        self.emit_param_reads(task_name, task_graph, indent);
        indent
    }

    fn emit_task_schedule_dispatch(
        &mut self,
        task_name: &str,
        task_graph: &TaskGraph,
        schedule: &TaskSchedule,
        indent: &str,
        tick_hoisted_actors: &HashMap<NodeId, String>,
    ) {
        match schedule {
            TaskSchedule::Pipeline(sched) => {
                let TaskGraph::Pipeline(sub) = task_graph else {
                    return;
                };
                self.emit_subgraph_firings(
                    task_name,
                    "pipeline",
                    sub,
                    sched,
                    indent,
                    tick_hoisted_actors,
                );
            }
            TaskSchedule::Modal { control, modes: _ } => {
                let TaskGraph::Modal {
                    control: ctrl_sub,
                    modes: _mode_subs,
                } = task_graph
                else {
                    return;
                };

                let _ = writeln!(self.out, "{}// Control subgraph", indent);
                self.emit_subgraph_firings(
                    task_name,
                    "control",
                    ctrl_sub,
                    control,
                    indent,
                    tick_hoisted_actors,
                );

                // Modal dispatch via LIR
                let lir = self.lir;
                if let Some(lir_task) = lir.tasks.iter().find(|t| t.name == task_name) {
                    if let LirTaskBody::Modal(modal) = &lir_task.body {
                        self.emit_lir_ctrl_source_read(task_name, &modal.ctrl_source, indent);
                        let _ = writeln!(
                            self.out,
                            "{}if (_active_mode != -1 && _ctrl != _active_mode) {{",
                            indent
                        );
                        self.emit_lir_mode_feedback_resets(modal, &format!("{}    ", indent));
                        let _ = writeln!(self.out, "{}}}", indent);
                        let _ = writeln!(self.out, "{}_active_mode = _ctrl;", indent);

                        let _ = writeln!(self.out, "{}switch (_ctrl) {{", indent);
                        for (i, (_mode_name, mode_sg)) in modal.modes.iter().enumerate() {
                            let _ = writeln!(self.out, "{}case {}: {{", indent, i);
                            self.emit_lir_subgraph(
                                task_name,
                                mode_sg,
                                &format!("{}    ", indent),
                                tick_hoisted_actors,
                            );
                            let _ = writeln!(self.out, "{}    break;", indent);
                            let _ = writeln!(self.out, "{}}}", indent);
                        }
                        let _ = writeln!(self.out, "{}default: break;", indent);
                        let _ = writeln!(self.out, "{}}}", indent);
                    }
                }
            }
        }
    }

    // ── Subgraph firing sequence ────────────────────────────────────────

    fn emit_subgraph_firings(
        &mut self,
        task_name: &str,
        label: &str,
        _sub: &Subgraph,
        _sched: &SubgraphSchedule,
        indent: &str,
        tick_hoisted_actors: &HashMap<NodeId, String>,
    ) {
        // LIR path: find the corresponding LIR subgraph and emit from it
        let lir = self.lir;
        if let Some(lir_task) = lir.tasks.iter().find(|t| t.name == task_name) {
            let lir_sg = match &lir_task.body {
                LirTaskBody::Pipeline(sg) if label == "pipeline" => Some(sg),
                LirTaskBody::Modal(modal) => {
                    if label == "control" {
                        Some(&modal.control)
                    } else {
                        modal
                            .modes
                            .iter()
                            .find(|(n, _)| n == label)
                            .map(|(_, sg)| sg)
                    }
                }
                _ => None,
            };
            if let Some(lir_sg) = lir_sg {
                self.emit_lir_subgraph(task_name, lir_sg, indent, tick_hoisted_actors);
            }
        }
    }

    fn emit_compact_input_copy(
        &mut self,
        indent: &str,
        dst_buf: &str,
        dst_offset: u32,
        src_expr: &str,
        tokens: u32,
        cpp_type: &str,
    ) {
        match tokens {
            0 => {}
            1 => {
                let _ = writeln!(
                    self.out,
                    "{}{}[{}] = ({})[0];",
                    indent, dst_buf, dst_offset, src_expr
                );
            }
            2..=4 => {
                for i in 0..tokens {
                    let _ = writeln!(
                        self.out,
                        "{}{}[{}] = ({})[{}];",
                        indent,
                        dst_buf,
                        dst_offset + i,
                        src_expr,
                        i
                    );
                }
            }
            _ => {
                let _ = writeln!(
                    self.out,
                    "{}std::memcpy(&{}[{}], {}, {} * sizeof({}));",
                    indent, dst_buf, dst_offset, src_expr, tokens, cpp_type
                );
            }
        }
    }

    // ── Feedback buffer handling ────────────────────────────────────────

    fn emit_feedback_buffers(
        &mut self,
        task_name: &str,
        _task_graph: &TaskGraph,
        _task_schedule: &TaskSchedule,
    ) {
        let lir = self.lir;
        if let Some(lir_task) = lir.tasks.iter().find(|t| t.name == task_name) {
            for fb in &lir_task.feedback_buffers {
                let _ = writeln!(
                    self.out,
                    "    {} {}[{}] = {{{}}};",
                    fb.cpp_type, fb.var_name, fb.tokens, fb.init_val
                );
            }
        }
    }

    // ── Runtime param reads ─────────────────────────────────────────────

    fn emit_param_reads(&mut self, task_name: &str, _task_graph: &TaskGraph, indent: &str) {
        let lir = self.lir;
        if let Some(lir_task) = lir.tasks.iter().find(|t| t.name == task_name) {
            for param in &lir_task.used_params {
                let _ = writeln!(
                    self.out,
                    "{}_param_{}_read.store(_param_{}_write.load(std::memory_order_acquire), std::memory_order_release);",
                    indent, param.name, param.name
                );
                let _ = writeln!(
                    self.out,
                    "{}{} _param_{}_val = _param_{}_read.load(std::memory_order_acquire);",
                    indent, param.cpp_type, param.name, param.name
                );
            }
        }
    }

    // ── Phase 7: main() ─────────────────────────────────────────────────

    fn emit_main(&mut self) {
        let lir = self.lir;

        self.out.push_str("int main(int argc, char* argv[]) {\n");

        // Param descriptors
        if !lir.params.is_empty() {
            self.out
                .push_str("    static const pipit::ParamDesc _param_descs[] = {\n");
            let mut sorted_params: Vec<&_> = lir.params.iter().collect();
            sorted_params.sort_by_key(|p| &p.name);
            for p in &sorted_params {
                let _ = writeln!(
                    self.out,
                    "        {{\"{}\", [](const char* v) -> bool {{ try {{ _param_{}_write.store({}(v), std::memory_order_release); return true; }} catch (...) {{ return false; }} }}}},",
                    p.name, p.name, p.cli_converter
                );
            }
            self.out.push_str("    };\n");
        }

        // Task descriptors
        self.out
            .push_str("    static const pipit::TaskDesc _task_descs[] = {\n");
        for task in &lir.tasks {
            let _ = writeln!(
                self.out,
                "        {{\"{}\", task_{}, &_stats_{}}},",
                task.name, task.name, task.name
            );
        }
        self.out.push_str("    };\n");

        // Buffer descriptors
        if !lir.inter_task_buffers.is_empty() {
            self.out
                .push_str("    static const pipit::BufferStatsDesc _buffer_descs[] = {\n");
            for buf in &lir.inter_task_buffers {
                let _ = writeln!(
                    self.out,
                    "        {{\"{}\", []() -> size_t {{ return _ringbuf_{}.available(); }}, sizeof({})}},",
                    buf.name, buf.name, buf.cpp_type
                );
            }
            self.out.push_str("    };\n");
        }

        // Probe descriptors (debug mode only, when probes exist)
        let has_probe_descs = !lir.probes.is_empty() && !self.options.release;
        if has_probe_descs {
            self.out
                .push_str("    static const pipit::ProbeDesc _probe_descs[] = {\n");
            for probe in &lir.probes {
                let _ = writeln!(
                    self.out,
                    "        {{\"{}\", &_probe_{}_enabled}},",
                    probe.name, probe.name
                );
            }
            self.out.push_str("    };\n");
        }

        // ProgramDesc initialization
        self.out.push_str("    pipit::ProgramDesc _desc{};\n");
        self.out.push_str(
            "    _desc.state = {&_stop, &_exit_code, &_start, &_stats, &_probe_output_file};\n",
        );

        if lir.params.is_empty() {
            self.out
                .push_str("    _desc.params = std::span<const pipit::ParamDesc>{};\n");
        } else {
            self.out.push_str("    _desc.params = _param_descs;\n");
        }

        self.out.push_str("    _desc.tasks = _task_descs;\n");

        if lir.inter_task_buffers.is_empty() {
            self.out
                .push_str("    _desc.buffers = std::span<const pipit::BufferStatsDesc>{};\n");
        } else {
            self.out.push_str("    _desc.buffers = _buffer_descs;\n");
        }

        if has_probe_descs {
            self.out.push_str("    _desc.probes = _probe_descs;\n");
        } else {
            self.out
                .push_str("    _desc.probes = std::span<const pipit::ProbeDesc>{};\n");
        }

        let policy = self.get_overrun_policy().to_string();
        let _ = writeln!(self.out, "    _desc.overrun_policy = \"{}\";", policy);
        let _ = writeln!(
            self.out,
            "    _desc.mem_allocated = {};",
            lir.directives.mem_bytes
        );
        let _ = writeln!(self.out, "    _desc.mem_used = {};", lir.total_memory);

        self.out
            .push_str("    return pipit::shell_main(argc, argv, _desc);\n");
        self.out.push_str("}\n");
    }

    // ── Helpers ─────────────────────────────────────────────────────────

    fn get_overrun_policy(&self) -> &str {
        &self.lir.directives.overrun_policy
    }

    // ── LIR-based emission methods ────────────────────────────────────────

    /// Emit all firings for a LIR subgraph: edge buffer declarations + firing groups.
    fn emit_lir_subgraph(
        &mut self,
        task_name: &str,
        lir_sg: &LirSubgraph,
        indent: &str,
        tick_hoisted: &HashMap<NodeId, String>,
    ) {
        // Declare edge buffers (skip feedback and aliased)
        for eb in &lir_sg.edge_buffers {
            if eb.is_feedback || eb.alias_of.is_some() {
                continue;
            }
            let _ = writeln!(
                self.out,
                "{}alignas(64) static {} {}[{}];",
                indent, eb.cpp_type, eb.var_name, eb.tokens
            );
        }

        // Emit firing groups
        for group in &lir_sg.firings {
            match group {
                LirFiringGroup::Single(firing) => {
                    self.emit_lir_single_firing(task_name, firing, indent, tick_hoisted);
                }
                LirFiringGroup::Fused(chain) => {
                    self.emit_lir_fused_chain(task_name, chain, indent, tick_hoisted);
                }
            }
        }
    }

    /// Emit a single LIR firing with optional repetition loop.
    fn emit_lir_single_firing(
        &mut self,
        task_name: &str,
        firing: &LirFiring,
        indent: &str,
        tick_hoisted: &HashMap<NodeId, String>,
    ) {
        // For actors: determine hoisted var (tick-level first, then rep-level)
        // and potentially emit rep-level hoisted declaration before loop
        let mut rep_hoisted_var: Option<String> = None;
        if let LirFiringKind::Actor(actor) = &firing.kind {
            if tick_hoisted.contains_key(&actor.node_id) {
                // Already tick-hoisted, will use that var
            } else if firing.needs_loop {
                // Rep-level hoist: emit declaration before the loop
                if let Some(h) = &actor.hoisted {
                    self.emit_lir_hoisted_decl(h, indent);
                    rep_hoisted_var = Some(h.var_name.clone());
                }
            }
        }

        let (body_indent, close_loop) = if firing.needs_loop {
            let _ = writeln!(
                self.out,
                "{}for (int _r = 0; _r < {}; ++_r) {{",
                indent, firing.repetition
            );
            (format!("{}    ", indent), true)
        } else {
            (indent.to_string(), false)
        };
        let ind = body_indent.as_str();

        match &firing.kind {
            LirFiringKind::Actor(actor) => {
                let hoisted_var = tick_hoisted
                    .get(&actor.node_id)
                    .map(|s| s.as_str())
                    .or(rep_hoisted_var.as_deref());
                self.emit_lir_actor_call(task_name, actor, ind, firing.repetition, hoisted_var);
            }
            LirFiringKind::Fork(fork) => {
                let _ = writeln!(self.out, "{}// fork: {} (zero-copy)", ind, fork.tap_name);
            }
            LirFiringKind::Probe(probe) => {
                // Probes are standalone (no _r loop), so always emit full buffer
                self.emit_lir_probe(probe, ind, 1);
            }
            LirFiringKind::BufferRead(io) => {
                self.emit_lir_buffer_read(task_name, io, ind);
            }
            LirFiringKind::BufferWrite(io) => {
                if !io.skip {
                    self.emit_lir_buffer_write(task_name, io, ind);
                }
            }
        }

        if close_loop {
            let _ = writeln!(self.out, "{}}}", indent);
        }
    }

    /// Emit a fused actor chain from LIR.
    fn emit_lir_fused_chain(
        &mut self,
        task_name: &str,
        chain: &LirFusedChain,
        indent: &str,
        tick_hoisted: &HashMap<NodeId, String>,
    ) {
        // Emit rep-level hoisted actor declarations (skip tick-hoisted ones)
        for hoisted in &chain.hoisted_actors {
            if let Some(id_str) = hoisted.var_name.strip_prefix("_actor_") {
                if let Ok(id) = id_str.parse::<u32>() {
                    if tick_hoisted.contains_key(&NodeId(id)) {
                        continue; // Already declared at tick level
                    }
                }
            }
            self.emit_lir_hoisted_decl(hoisted, indent);
        }

        // Emit fork comments before loop
        for firing in &chain.body {
            if let LirFiringKind::Fork(fork) = &firing.kind {
                let _ = writeln!(self.out, "{}// fork: {} (zero-copy)", indent, fork.tap_name);
            }
        }

        // Open fused loop
        let _ = writeln!(
            self.out,
            "{}for (int _r = 0; _r < {}; ++_r) {{",
            indent, chain.repetition
        );
        let body_indent = format!("{}    ", indent);
        let ind = body_indent.as_str();

        // Emit each firing in the chain
        for firing in &chain.body {
            match &firing.kind {
                LirFiringKind::Actor(actor) => {
                    // Priority: tick-hoisted > chain-hoisted > actor-hoisted
                    let hoisted_var = tick_hoisted
                        .get(&actor.node_id)
                        .map(|s| s.as_str())
                        .or_else(|| {
                            chain
                                .hoisted_actors
                                .iter()
                                .find(|h| h.var_name == format!("_actor_{}", actor.node_id.0))
                                .map(|h| h.var_name.as_str())
                        })
                        .or_else(|| actor.hoisted.as_ref().map(|h| h.var_name.as_str()));
                    self.emit_lir_actor_call(task_name, actor, ind, chain.repetition, hoisted_var);
                }
                LirFiringKind::Fork(_) => {} // Already emitted above
                LirFiringKind::Probe(probe) => {
                    self.emit_lir_probe(probe, ind, chain.repetition);
                }
                _ => {}
            }
        }

        let _ = writeln!(self.out, "{}}}", indent);
    }

    /// Emit a hoisted actor declaration.
    fn emit_lir_hoisted_decl(&mut self, hoisted: &LirHoistedActor, indent: &str) {
        let params = format_lir_actor_args(&hoisted.params);
        if params.is_empty() {
            let _ = writeln!(
                self.out,
                "{}auto {} = {}{{}};",
                indent, hoisted.var_name, hoisted.cpp_name
            );
        } else {
            let _ = writeln!(
                self.out,
                "{}auto {} = {}{{{}}};",
                indent, hoisted.var_name, hoisted.cpp_name, params
            );
        }
    }

    /// Emit an actor call from LIR with error handling.
    fn emit_lir_actor_call(
        &mut self,
        task_name: &str,
        actor: &LirActorFiring,
        indent: &str,
        rep: u32,
        hoisted_var: Option<&str>,
    ) {
        let in_ptr = self.build_lir_input_ptr(actor, indent, rep);
        let out_ptr = build_lir_output_ptr(actor, rep);

        let call_expr = if let Some(var_name) = hoisted_var {
            format!("{}.operator()({}, {})", var_name, in_ptr, out_ptr)
        } else {
            let params = format_lir_actor_args(&actor.params);
            if params.is_empty() {
                format!("{}{{}}({}, {})", actor.cpp_name, in_ptr, out_ptr)
            } else {
                format!(
                    "{}{{{}}}.operator()({}, {})",
                    actor.cpp_name, params, in_ptr, out_ptr
                )
            }
        };

        let _ = writeln!(self.out, "{}if ({} != ACTOR_OK) {{", indent, call_expr);
        let _ = writeln!(
            self.out,
            "{}    fprintf(stderr, \"runtime error: actor '{}' in task '{}' returned ACTOR_ERROR\\n\");",
            indent, actor.actor_name, task_name
        );
        let _ = writeln!(
            self.out,
            "{}    _exit_code.store(1, std::memory_order_release);",
            indent
        );
        let _ = writeln!(
            self.out,
            "{}    _stop.store(true, std::memory_order_release);",
            indent
        );
        let _ = writeln!(self.out, "{}    return;", indent);
        let _ = writeln!(self.out, "{}}}", indent);
    }

    /// Build input pointer expression from LIR actor data.
    fn build_lir_input_ptr(&mut self, actor: &LirActorFiring, indent: &str, rep: u32) -> String {
        if actor.in_type == "void" || actor.inputs.is_empty() {
            return "nullptr".to_string();
        }
        if actor.inputs.len() == 1 {
            let input = &actor.inputs[0];
            if rep > 1 {
                let stride = actor.in_rate.unwrap_or_else(|| input.tokens / rep);
                return format!("&{}[_r * {}]", input.buffer_var, stride);
            }
            return input.buffer_var.clone();
        }

        // Multi-input: concatenate slices into local buffer
        let mut segments: Vec<(String, u32)> = Vec::with_capacity(actor.inputs.len());
        for input in &actor.inputs {
            let tokens_per_firing = if rep > 1 {
                input.tokens / rep
            } else {
                input.tokens
            };
            let src_expr = if rep > 1 {
                format!("&{}[_r * {}]", input.buffer_var, tokens_per_firing)
            } else {
                input.buffer_var.clone()
            };
            segments.push((src_expr, tokens_per_firing));
        }
        if segments.is_empty() {
            return "nullptr".to_string();
        }

        let total_tokens: u32 = segments.iter().map(|(_, n)| *n).sum();
        let effective_in = actor.in_rate.unwrap_or(total_tokens);
        let local_in = format!("_in_{}", actor.node_id.0);
        if total_tokens == effective_in {
            let _ = writeln!(
                self.out,
                "{}{} {}[{}];",
                indent, actor.in_type, local_in, effective_in
            );
        } else {
            let _ = writeln!(
                self.out,
                "{}{} {}[{}] = {{}};",
                indent, actor.in_type, local_in, effective_in
            );
        }

        let mut offset = 0u32;
        for (src_expr, tokens) in segments {
            if offset >= effective_in {
                break;
            }
            let copy_tokens = tokens.min(effective_in - offset);
            self.emit_compact_input_copy(
                indent,
                &local_in,
                offset,
                src_expr.as_str(),
                copy_tokens,
                actor.in_type,
            );
            offset += copy_tokens;
        }
        local_in
    }

    /// Emit shared buffer read from LIR data.
    fn emit_lir_buffer_read(&mut self, task_name: &str, io: &LirBufferIo, indent: &str) {
        let reader_idx = io.reader_idx.unwrap_or(0);
        let _ = writeln!(
            self.out,
            "{}int _rb_retry_{}_{} = 0;",
            indent, io.src_node_id.0, io.peer_node_id.0
        );
        let _ = writeln!(self.out, "{}while (true) {{", indent);
        let _ = writeln!(
            self.out,
            "{}    if (!_ringbuf_{}.read({}, {}, {})) {{",
            indent, io.buffer_name, reader_idx, io.edge_var, io.total_tokens
        );
        let _ = writeln!(
            self.out,
            "{}        if (_stop.load(std::memory_order_acquire)) {{",
            indent
        );
        let _ = writeln!(self.out, "{}            return;", indent);
        let _ = writeln!(self.out, "{}        }}", indent);
        let _ = writeln!(
            self.out,
            "{}        if (++_rb_retry_{}_{} < 1000000) {{",
            indent, io.src_node_id.0, io.peer_node_id.0
        );
        let _ = writeln!(self.out, "{}            std::this_thread::yield();", indent);
        let _ = writeln!(self.out, "{}            continue;", indent);
        let _ = writeln!(self.out, "{}        }}", indent);
        let _ = writeln!(
            self.out,
            "{}        std::fprintf(stderr, \"runtime error: task '{}' failed to read {} token(s) from shared buffer '{}'\\n\");",
            indent, task_name, io.total_tokens, io.buffer_name
        );
        let _ = writeln!(
            self.out,
            "{}        _exit_code.store(1, std::memory_order_release);",
            indent
        );
        let _ = writeln!(
            self.out,
            "{}        _stop.store(true, std::memory_order_release);",
            indent
        );
        let _ = writeln!(self.out, "{}        return;", indent);
        let _ = writeln!(self.out, "{}    }}", indent);
        let _ = writeln!(self.out, "{}    break;", indent);
        let _ = writeln!(self.out, "{}}}", indent);
    }

    /// Emit shared buffer write from LIR data.
    fn emit_lir_buffer_write(&mut self, task_name: &str, io: &LirBufferIo, indent: &str) {
        let _ = writeln!(
            self.out,
            "{}int _rb_retry_{}_{} = 0;",
            indent, io.src_node_id.0, io.peer_node_id.0
        );
        let _ = writeln!(self.out, "{}while (true) {{", indent);
        let _ = writeln!(
            self.out,
            "{}    if (!_ringbuf_{}.write({}, {})) {{",
            indent, io.buffer_name, io.edge_var, io.total_tokens
        );
        let _ = writeln!(
            self.out,
            "{}        if (_stop.load(std::memory_order_acquire)) {{",
            indent
        );
        let _ = writeln!(self.out, "{}            return;", indent);
        let _ = writeln!(self.out, "{}        }}", indent);
        let _ = writeln!(
            self.out,
            "{}        if (++_rb_retry_{}_{} < 1000000) {{",
            indent, io.src_node_id.0, io.peer_node_id.0
        );
        let _ = writeln!(self.out, "{}            std::this_thread::yield();", indent);
        let _ = writeln!(self.out, "{}            continue;", indent);
        let _ = writeln!(self.out, "{}        }}", indent);
        let _ = writeln!(
            self.out,
            "{}        std::fprintf(stderr, \"runtime error: task '{}' failed to write {} token(s) to shared buffer '{}'\\n\");",
            indent, task_name, io.total_tokens, io.buffer_name
        );
        let _ = writeln!(
            self.out,
            "{}        _exit_code.store(1, std::memory_order_release);",
            indent
        );
        let _ = writeln!(
            self.out,
            "{}        _stop.store(true, std::memory_order_release);",
            indent
        );
        let _ = writeln!(self.out, "{}        return;", indent);
        let _ = writeln!(self.out, "{}    }}", indent);
        let _ = writeln!(self.out, "{}    break;", indent);
        let _ = writeln!(self.out, "{}}}", indent);
    }

    /// Emit probe observation from LIR data.
    fn emit_lir_probe(&mut self, probe: &LirProbeFiring, indent: &str, rep: u32) {
        if self.options.release {
            return;
        }
        let (count, src_expr) = if rep > 1 {
            let per_firing = probe.tokens / rep;
            if per_firing == 0 {
                return;
            }
            (
                per_firing,
                format!("&{}[_r * {}]", probe.src_var, per_firing),
            )
        } else {
            (probe.tokens, probe.src_var.clone())
        };
        let _ = writeln!(self.out, "{}#ifndef NDEBUG", indent);
        let _ = writeln!(
            self.out,
            "{}if (_probe_{}_enabled) {{",
            indent, probe.probe_name
        );
        let _ = writeln!(
            self.out,
            "{}    for (int _pi = 0; _pi < {}; ++_pi)",
            indent, count
        );
        let _ = writeln!(
            self.out,
            "{}        fprintf(_probe_output_file, \"[probe:{}] {}\\n\", ({})[_pi]);",
            indent, probe.probe_name, probe.fmt_spec, src_expr
        );
        let _ = writeln!(self.out, "{}    fflush(_probe_output_file);", indent);
        let _ = writeln!(self.out, "{}}}", indent);
        let _ = writeln!(self.out, "{}#endif", indent);
    }

    /// Emit ctrl source read from LIR modal data.
    fn emit_lir_ctrl_source_read(
        &mut self,
        task_name: &str,
        ctrl_source: &LirCtrlSource,
        indent: &str,
    ) {
        match ctrl_source {
            LirCtrlSource::Param { name } => {
                let _ = writeln!(
                    self.out,
                    "{}int32_t _ctrl = static_cast<int32_t>(_param_{}_val);",
                    indent, name
                );
            }
            LirCtrlSource::EdgeBuffer { var_name } => {
                let _ = writeln!(self.out, "{}int32_t _ctrl = {};", indent, var_name);
            }
            LirCtrlSource::RingBuffer { name, reader_idx } => {
                let _ = writeln!(self.out, "{}int32_t _ctrl_buf[1];", indent);
                let _ = writeln!(
                    self.out,
                    "{}if (!_ringbuf_{}.read({}, _ctrl_buf, 1)) {{",
                    indent, name, reader_idx
                );
                let _ = writeln!(
                    self.out,
                    "{}    std::fprintf(stderr, \"runtime error: task '{}' failed to read 1 token(s) from shared buffer '{}' for switch ctrl\\n\");",
                    indent, task_name, name
                );
                let _ = writeln!(
                    self.out,
                    "{}    _exit_code.store(1, std::memory_order_release);",
                    indent
                );
                let _ = writeln!(
                    self.out,
                    "{}    _stop.store(true, std::memory_order_release);",
                    indent
                );
                let _ = writeln!(self.out, "{}    return;", indent);
                let _ = writeln!(self.out, "{}}}", indent);
                let _ = writeln!(self.out, "{}int32_t _ctrl = _ctrl_buf[0];", indent);
            }
        }
    }

    /// Emit mode feedback resets from LIR modal data.
    fn emit_lir_mode_feedback_resets(&mut self, modal: &LirModalBody, indent: &str) {
        for resets in &modal.mode_feedback_resets {
            for reset in resets {
                if reset.tokens <= 1 {
                    let _ = writeln!(
                        self.out,
                        "{}{}[0] = {};",
                        indent, reset.var_name, reset.init_val
                    );
                } else {
                    let _ = writeln!(
                        self.out,
                        "{}for (int _fb_i = 0; _fb_i < {}; ++_fb_i) {}[_fb_i] = {};",
                        indent, reset.tokens, reset.var_name, reset.init_val
                    );
                }
            }
        }
    }
}

// ── Free helpers ────────────────────────────────────────────────────────────

/// Collect all hoisted actor declarations from a LIR task body (free function
/// to avoid borrow conflicts with &mut self emission methods).
/// Collect tick-hoistable actors (above K-loop) from all subgraphs.
/// Returns (var_name, cpp_name, params) tuples for declaration emission.
fn collect_lir_tick_hoistable_actors(
    body: &LirTaskBody,
) -> Vec<(String, String, Vec<LirActorArg>)> {
    let mut result = Vec::new();
    let mut seen = std::collections::HashSet::new();
    let subgraphs: Vec<&LirSubgraph> = match body {
        LirTaskBody::Pipeline(sg) => vec![sg],
        LirTaskBody::Modal(modal) => {
            let mut sgs = vec![&modal.control];
            for (_, sg) in &modal.modes {
                sgs.push(sg);
            }
            sgs
        }
    };
    for sg in subgraphs {
        for group in &sg.firings {
            let actors: Vec<&LirActorFiring> = match group {
                LirFiringGroup::Single(firing) => {
                    if let LirFiringKind::Actor(actor) = &firing.kind {
                        vec![actor]
                    } else {
                        vec![]
                    }
                }
                LirFiringGroup::Fused(chain) => chain
                    .body
                    .iter()
                    .filter_map(|f| {
                        if let LirFiringKind::Actor(actor) = &f.kind {
                            Some(actor)
                        } else {
                            None
                        }
                    })
                    .collect(),
            };
            for actor in actors {
                if actor.tick_hoistable && seen.insert(actor.node_id) {
                    result.push((
                        format!("_actor_{}", actor.node_id.0),
                        actor.cpp_name.clone(),
                        actor.params.clone(),
                    ));
                }
            }
        }
    }
    result
}

/// Format a single LIR actor arg to C++ string.
fn format_lir_actor_arg(arg: &LirActorArg) -> String {
    match arg {
        LirActorArg::Literal(s) => s.clone(),
        LirActorArg::ParamRef(name) => format!("_param_{}_val", name),
        LirActorArg::ConstScalar(literal) => literal.clone(),
        LirActorArg::ConstSpan { name, len } => {
            format!("std::span<const float>(_const_{}, {})", name, len)
        }
        LirActorArg::ConstArrayLen(len) => format!("{}", len),
        LirActorArg::DimValue(val) => format!("{}", val),
    }
}

/// Format all LIR actor args into a comma-separated C++ parameter string.
fn format_lir_actor_args(args: &[LirActorArg]) -> String {
    args.iter()
        .map(format_lir_actor_arg)
        .collect::<Vec<_>>()
        .join(", ")
}

/// Build output pointer expression from LIR actor data (free function to avoid borrow issues).
fn build_lir_output_ptr(actor: &LirActorFiring, rep: u32) -> String {
    if actor.void_output || actor.outputs.is_empty() {
        return "nullptr".to_string();
    }
    let output = &actor.outputs[0];
    if rep > 1 {
        let stride = actor.out_rate.unwrap_or_else(|| output.tokens / rep);
        format!("&{}[_r * {}]", output.buffer_var, stride)
    } else {
        output.buffer_var.clone()
    }
}

// ── Tests ───────────────────────────────────────────────────────────────────
// Unit tests: verify structural and semantic properties of generated C++ strings
// (firing order, buffer layout, probe stripping) without a C++ compiler.
// Complements compiler/tests/codegen_compile.rs (compilation + runtime checks).

#[cfg(test)]
mod tests {
    use super::*;
    use crate::diag::DiagLevel;
    use crate::registry::Registry;
    use crate::resolve;
    use std::path::PathBuf;

    fn test_registry() -> Registry {
        let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .to_path_buf();
        let std_actors = root.join("runtime/libpipit/include/std_actors.h");
        let std_math = root.join("runtime/libpipit/include/std_math.h");
        let example_actors = root.join("examples/example_actors.h");
        let std_sink = root.join("runtime/libpipit/include/std_sink.h");
        let std_source = root.join("runtime/libpipit/include/std_source.h");
        let mut reg = Registry::new();
        reg.load_header(&std_actors)
            .expect("failed to load std_actors.h");
        reg.load_header(&std_math)
            .expect("failed to load std_math.h");
        reg.load_header(&example_actors)
            .expect("failed to load example_actors.h");
        reg.load_header(&std_sink)
            .expect("failed to load std_sink.h");
        reg.load_header(&std_source)
            .expect("failed to load std_source.h");
        reg
    }

    fn codegen_source_with_options(
        source: &str,
        registry: &Registry,
        options: CodegenOptions,
    ) -> CodegenResult {
        let parse_result = crate::parser::parse(source);
        assert!(
            parse_result.errors.is_empty(),
            "parse errors: {:?}",
            parse_result.errors
        );
        let program = parse_result.program.expect("parse failed");
        let mut resolve_result = resolve::resolve(&program, registry);
        assert!(
            resolve_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "resolve errors: {:#?}",
            resolve_result.diagnostics
        );
        let hir_program = crate::hir::build_hir(
            &program,
            &resolve_result.resolved,
            &mut resolve_result.id_alloc,
        );
        let graph_result =
            crate::graph::build_graph(&hir_program, &resolve_result.resolved, registry);
        assert!(
            graph_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "graph errors: {:#?}",
            graph_result.diagnostics
        );
        let type_result =
            crate::type_infer::type_infer(&hir_program, &resolve_result.resolved, registry);
        let lower_result = crate::lower::lower_and_verify(
            &hir_program,
            &resolve_result.resolved,
            &type_result.typed,
            registry,
        );
        let thir = crate::thir::build_thir_context(
            &hir_program,
            &resolve_result.resolved,
            &type_result.typed,
            &lower_result.lowered,
            registry,
            &graph_result.graph,
        );
        let analysis_result = crate::analyze::analyze(&thir, &graph_result.graph);
        assert!(
            analysis_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "analysis errors: {:#?}",
            analysis_result.diagnostics
        );
        let schedule_result =
            crate::schedule::schedule(&thir, &graph_result.graph, &analysis_result.analysis);
        assert!(
            schedule_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "schedule errors: {:#?}",
            schedule_result.diagnostics
        );
        let lir = crate::lir::build_lir(
            &thir,
            &graph_result.graph,
            &analysis_result.analysis,
            &schedule_result.schedule,
        );
        let mut ctx = CodegenCtx::new(
            &graph_result.graph,
            &schedule_result.schedule,
            &options,
            &lir,
        );
        ctx.emit_all();
        ctx.build_result()
    }

    fn codegen_source(source: &str, registry: &Registry) -> CodegenResult {
        codegen_source_with_options(
            source,
            registry,
            CodegenOptions {
                release: false,
                include_paths: vec![],
                provenance: None,
            },
        )
    }

    fn codegen_ok(source: &str, registry: &Registry) -> String {
        let result = codegen_source(source, registry);
        let errors: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| d.level == DiagLevel::Error)
            .collect();
        assert!(
            errors.is_empty(),
            "unexpected codegen errors: {:#?}",
            errors
        );
        result.generated.cpp_source
    }

    fn count_occurrences(haystack: &str, needle: &str) -> usize {
        haystack.match_indices(needle).count()
    }

    // ── Const emission tests ────────────────────────────────────────────

    #[test]
    fn const_array_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "const coeff = [0.1, 0.2, 0.4]\nclock 1kHz t { constant(0.0) | fir(coeff) | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("static constexpr float _const_coeff[]"),
            "should emit const array"
        );
        assert!(cpp.contains("0.1f"), "should have float literals");
    }

    #[test]
    fn const_scalar_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "const fft_size = 256\nclock 1kHz t { constant(0.0) | fft(fft_size) | c2r() | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("static constexpr auto _const_fft_size = 256;"),
            "should emit const scalar: {}",
            cpp
        );
    }

    // ── Param storage tests ─────────────────────────────────────────────

    #[test]
    fn param_storage_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "param gain = 2.5\nclock 1kHz t { constant(0.0) | mul($gain) | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("std::atomic<float> _param_gain_write(2.5f)")
                && cpp.contains("std::atomic<float> _param_gain_read(2.5f)")
                && cpp.contains(
                    "_param_gain_read.store(_param_gain_write.load(std::memory_order_acquire)"
                ),
            "should emit param read/write buffers: {}",
            cpp
        );
    }

    // ── Actor firing tests ──────────────────────────────────────────────

    #[test]
    fn source_actor_firing() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("Actor_constant"),
            "should fire constant actor: {}",
            cpp
        );
        assert!(
            cpp.contains("Actor_stdout"),
            "should fire stdout actor: {}",
            cpp
        );
        // Verify topological firing order
        let pos_const = cpp.find("Actor_constant").unwrap();
        let pos_stdout = cpp.find("Actor_stdout").unwrap();
        assert!(
            pos_const < pos_stdout,
            "constant must fire before stdout in schedule order"
        );
    }

    #[test]
    fn transform_actor_firing() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "clock 1kHz t { constant(0.0) | fft(256) | c2r() | stdout() }",
            &reg,
        );
        assert!(cpp.contains("Actor_fft"), "should fire fft actor: {}", cpp);
        assert!(cpp.contains("Actor_c2r"), "should fire c2r actor: {}", cpp);
        // Verify full topological firing order
        let pos_const = cpp.find("Actor_constant").unwrap();
        let pos_fft = cpp.find("Actor_fft").unwrap();
        let pos_c2r = cpp.find("Actor_c2r").unwrap();
        let pos_stdout = cpp.find("Actor_stdout").unwrap();
        assert!(pos_const < pos_fft, "constant must fire before fft");
        assert!(pos_fft < pos_c2r, "fft must fire before c2r");
        assert!(pos_c2r < pos_stdout, "c2r must fire before stdout");
    }

    #[test]
    fn repetition_offset_emission() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "clock 1kHz t { constant(0.0) | fft(256) | c2r() | stdout() }",
            &reg,
        );
        // fft produces 256 tokens from 1 input; downstream actors repeat with _r offsets
        assert!(
            cpp.contains("for (int _r = 0; _r <"),
            "rate mismatch should produce _r repetition loop: {}",
            cpp
        );
        assert!(
            cpp.contains("_r *"),
            "repetition loop should use _r offset expressions: {}",
            cpp
        );
    }

    #[test]
    fn same_rep_chain_fused_into_single_r_loop() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "const coeff = [0.1, 0.2, 0.4, 0.2, 0.1]\n",
                "clock 1kHz t { constant(0.0) | fft(256) | c2r() | fir(coeff) | stdout() }",
            ),
            &reg,
        );
        assert_eq!(
            count_occurrences(&cpp, "for (int _r = 0; _r < 5; ++_r)"),
            1,
            "rep=5 chain should be fused into a single loop, got:\n{}",
            cpp
        );
    }

    #[test]
    fn rep_mismatch_not_fused() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "const coeff = [0.1, 0.2, 0.4, 0.2, 0.1]\n",
                "clock 1kHz t { constant(0.0) | fft(256) | c2r() | fir(coeff) | stdout() }",
            ),
            &reg,
        );
        assert_eq!(
            count_occurrences(&cpp, "for (int _r = 0; _r < 5; ++_r)"),
            1,
            "rep=5 actors should be fused once, got:\n{}",
            cpp
        );
        let pos_c2r_call = cpp
            .find("_actor_2.operator()(&_e1_2[_r * 256], &_e2_3[_r * 256])")
            .expect("expected c2r call in rep=5 loop");
        let pos_fir_loop = cpp
            .find("for (int _r = 0; _r < 256; ++_r)")
            .expect("expected separate rep=256 loop for fir");
        assert!(
            pos_c2r_call < pos_fir_loop,
            "rep mismatch boundary (c2r->fir) should remain separated, got:\n{}",
            cpp
        );
    }

    #[test]
    fn feedback_edge_not_fused() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "clock 1kHz iir {\n",
                "    constant(0.0)[4] | add(:fb) | mul(2.0) | :out | stdout()\n",
                "    :out | delay(1, 0.0) | :fb\n",
                "}\n"
            ),
            &reg,
        );
        assert!(
            cpp.contains("_fb_"),
            "feedback buffer should be present for cycle graph, got:\n{}",
            cpp
        );
        assert!(
            count_occurrences(&cpp, "for (int _r = 0; _r < ") >= 3,
            "feedback-related nodes should not be coalesced into a single fused loop, got:\n{}",
            cpp
        );
    }

    #[test]
    fn fork_passthrough_chain_fused_into_single_r_loop() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "const coeff = [0.1, 0.2, 0.4, 0.2, 0.1]\n",
                "clock 1kHz t {\n",
                "    constant(0.0)[256] | fft(256) | :raw | c2r() | fir(coeff) | stdout()\n",
                "    :raw | mag() | stdout()\n",
                "}\n"
            ),
            &reg,
        );
        assert_eq!(
            count_occurrences(&cpp, "for (int _r = 0; _r < 5; ++_r)"),
            1,
            "fork-branch same-rep region should be fused into one loop, got:\n{}",
            cpp
        );
    }

    #[test]
    fn probe_passthrough_fusion_uses_per_firing_slice() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "const coeff = [0.1, 0.2, 0.4, 0.2, 0.1]\n",
                "clock 1kHz t {\n",
                "    constant(0.0)[256] | fft(256) | ?spec | c2r() | fir(coeff) | stdout()\n",
                "}\n"
            ),
            &reg,
        );
        assert_eq!(
            count_occurrences(&cpp, "for (int _r = 0; _r < 5; ++_r)"),
            1,
            "probe passthrough chain should be fused into one loop, got:\n{}",
            cpp
        );
        assert!(
            cpp.contains("[probe:spec]"),
            "probe output formatting should be emitted in debug mode, got:\n{}",
            cpp
        );
        assert!(
            cpp.contains("for (int _pi = 0; _pi < 256; ++_pi)"),
            "fused probe should observe per-firing slice (256), got:\n{}",
            cpp
        );
        assert!(
            !cpp.contains("for (int _pi = 0; _pi < 1280; ++_pi)"),
            "fused probe should not replay full buffer per _r, got:\n{}",
            cpp
        );
        assert!(
            cpp.contains("_r * 256"),
            "fused probe should index by _r slice offset, got:\n{}",
            cpp
        );
    }

    // ── Task structure tests ────────────────────────────────────────────

    #[test]
    fn task_function_structure() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("void task_t()"),
            "should emit task function: {}",
            cpp
        );
        assert!(cpp.contains("pipit::Timer"), "should have timer: {}", cpp);
        assert!(
            cpp.contains("_stop.load"),
            "should check stop flag: {}",
            cpp
        );
    }

    #[test]
    fn runtime_context_hooks_emitted() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("pipit::detail::set_actor_task_rate_hz(1000.0);"),
            "should set task rate in runtime context: {}",
            cpp
        );
        assert!(
            cpp.contains("pipit::detail::set_actor_iteration_index(_iter_idx++);"),
            "should set iteration index per logical iteration: {}",
            cpp
        );
    }

    #[test]
    fn k_factor_loop() {
        let reg = test_registry();
        // default tick_rate = 10kHz → K = ceil(10MHz / 10kHz) = 1000, capped to MAX_K_FACTOR = 500
        let cpp = codegen_ok("clock 10MHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("for (int _k = 0; _k < 500; ++_k)"),
            "should have K-loop: {}",
            cpp
        );
        // Verify firing order within K-loop
        let pos_const = cpp.find("Actor_constant").unwrap();
        let pos_stdout = cpp.find("Actor_stdout").unwrap();
        assert!(
            pos_const < pos_stdout,
            "constant must fire before stdout within K-loop"
        );
    }

    #[test]
    fn iteration_stride_block_size() {
        let reg = test_registry();
        // sine[256] produces 256 samples per firing → stride = 256
        let cpp = codegen_ok(
            "clock 1kHz t { sine<float>(100.0, 1.0)[256] | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("_iter_idx += 256"),
            "should advance iteration index by block size 256: {}",
            cpp
        );
    }

    #[test]
    fn iteration_stride_unit_block() {
        // When block size is 1 (default), stride should be 1 → _iter_idx++
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("_iter_idx++"),
            "unit block should use _iter_idx++: {}",
            cpp
        );
    }

    // ── timer_spin tests ─────────────────────────────────────────────────

    #[test]
    fn timer_spin_default() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        // default timer_spin = 10000 (10us)
        assert!(
            cpp.contains("pipit::Timer _timer(1000.0, _stats, 10000);"),
            "default spin should be 10000ns: {}",
            cpp
        );
    }

    #[test]
    fn timer_spin_explicit() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "set timer_spin = 5000\nclock 1kHz t { constant(0.0) | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("pipit::Timer _timer(1000.0, _stats, 5000);"),
            "explicit spin should be 5000ns: {}",
            cpp
        );
    }

    #[test]
    fn timer_spin_auto() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "set timer_spin = auto\nclock 1kHz t { constant(0.0) | stdout() }",
            &reg,
        );
        // auto → sentinel -1 for adaptive EWMA mode
        assert!(
            cpp.contains("pipit::Timer _timer(1000.0, _stats, -1);"),
            "auto spin should emit sentinel -1: {}",
            cpp
        );
    }

    // ── Fork test ───────────────────────────────────────────────────────

    #[test]
    fn fork_zero_copy() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "clock 1kHz t { constant(0.0) | :raw | stdout()\n:raw | stdout() }",
            &reg,
        );
        // Fork should NOT use memcpy — downstream actors share the upstream buffer
        assert!(
            !cpp.contains("memcpy"),
            "fork should be zero-copy (no memcpy): {}",
            cpp
        );
        assert!(cpp.contains("// fork:"), "fork comment expected: {}", cpp);
    }

    // ── Shared buffer test ──────────────────────────────────────────────

    #[test]
    fn shared_buffer_declaration() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "set mem = 64MB\n",
                "clock 1kHz a { constant(0.0) -> sig }\n",
                "clock 1kHz b { @sig | stdout() }\n",
            ),
            &reg,
        );
        assert!(
            cpp.contains("pipit::RingBuffer<float"),
            "should declare ring buffer: {}",
            cpp
        );
        assert!(cpp.contains("_ringbuf_sig"), "should name buffer: {}", cpp);
    }

    // ── Main function test ──────────────────────────────────────────────

    #[test]
    fn main_with_shell() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "set mem = 64MB\n",
                "clock 1kHz a { constant(0.0) -> sig }\n",
                "clock 1kHz b { @sig | stdout() }\n",
            ),
            &reg,
        );
        assert!(cpp.contains("int main("), "should have main: {}", cpp);
        assert!(
            cpp.contains("pipit::shell_main("),
            "should call shell_main: {}",
            cpp
        );
        assert!(
            cpp.contains("pipit::TaskDesc"),
            "should have task descriptors: {}",
            cpp
        );
    }

    // ── Release mode tests ─────────────────────────────────────────────

    #[test]
    fn release_mode_strips_probes() {
        let reg = test_registry();
        let source = "clock 1kHz t { constant(0.0) | mul(1.0) | ?debug | stdout() }";

        // Debug mode: probe infrastructure present
        let debug_cpp = codegen_ok(source, &reg);
        assert!(
            debug_cpp.contains("#ifndef NDEBUG"),
            "debug build should contain #ifndef NDEBUG: {}",
            debug_cpp
        );
        assert!(
            debug_cpp.contains("_probe_debug_enabled"),
            "debug build should contain probe enable flag: {}",
            debug_cpp
        );

        // Release mode: probe infrastructure stripped
        let release_result = codegen_source_with_options(
            source,
            &reg,
            CodegenOptions {
                release: true,
                include_paths: vec![],
                provenance: None,
            },
        );
        let errors: Vec<_> = release_result
            .diagnostics
            .iter()
            .filter(|d| d.level == DiagLevel::Error)
            .collect();
        assert!(
            errors.is_empty(),
            "unexpected codegen errors: {:#?}",
            errors
        );
        let release_cpp = release_result.generated.cpp_source;

        assert!(
            !release_cpp.contains("#ifndef NDEBUG"),
            "release build should NOT contain #ifndef NDEBUG: {}",
            release_cpp
        );
        assert!(
            !release_cpp.contains("_probe_debug_enabled"),
            "release build should NOT contain probe enable flag: {}",
            release_cpp
        );
        assert!(
            !release_cpp.contains("[probe:"),
            "release build should NOT contain probe output formatting: {}",
            release_cpp
        );
    }

    #[test]
    fn probe_descriptors_emitted() {
        let reg = test_registry();
        let source = "clock 1kHz t { constant(0.0) | ?debug | stdout() }";
        let cpp = codegen_ok(source, &reg);
        assert!(
            cpp.contains("pipit::ProbeDesc"),
            "debug build should emit probe descriptors: {}",
            cpp
        );
        assert!(
            cpp.contains("_probe_debug_enabled"),
            "debug build should reference probe enable flag: {}",
            cpp
        );
        assert!(
            cpp.contains("_probe_output_file"),
            "should reference probe output file global: {}",
            cpp
        );
    }

    // ── Integration tests ───────────────────────────────────────────────

    #[test]
    fn gain_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/gain.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read gain.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(cpp.contains("Actor_mul"), "gain.pdl should have mul");
        assert!(cpp.contains("_param_gain"), "gain.pdl should ref param");
    }

    #[test]
    fn example_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/example.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read example.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(
            cpp.contains("pipit::RingBuffer"),
            "example.pdl should have inter-task buffer"
        );
        assert!(
            cpp.contains("pipit::shell_main("),
            "example.pdl should call shell_main"
        );
    }

    #[test]
    fn receiver_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/receiver.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read receiver.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(
            cpp.contains("switch (_ctrl)"),
            "receiver.pdl should have mode switch: {}",
            cpp
        );
        assert!(
            cpp.contains("int32_t _active_mode = -1;"),
            "receiver.pdl should track active mode for transition handling: {}",
            cpp
        );
    }

    #[test]
    fn switch_param_source_reads_runtime_param_for_ctrl() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "param sel = 0\n",
                "clock 1kHz t {\n",
                "    control {\n        constant(0.0) | stdout()\n    }\n",
                "    mode a {\n        constant(0.0) | stdout()\n    }\n",
                "    mode b {\n        constant(0.0) | stdout()\n    }\n",
                "    switch($sel, a, b)\n",
                "}\n"
            ),
            &reg,
        );
        assert!(
            cpp.contains("int32_t _ctrl = static_cast<int32_t>(_param_sel_val);"),
            "switch($param, ...) should read ctrl from runtime param: {}",
            cpp
        );
    }

    #[test]
    fn switch_external_buffer_source_reads_ring_buffer_for_ctrl() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "clock 1kHz producer {\n",
                "    constant(0.0) | detect() -> ctrl\n",
                "}\n",
                "clock 1kHz t {\n",
                "    control {\n        constant(0.0) | stdout()\n    }\n",
                "    mode a {\n        constant(0.0) | stdout()\n    }\n",
                "    mode b {\n        constant(0.0) | stdout()\n    }\n",
                "    switch(ctrl, a, b)\n",
                "}\n"
            ),
            &reg,
        );
        assert!(
            cpp.contains("_ringbuf_ctrl.read(") && cpp.contains("int32_t _ctrl = _ctrl_buf[0];"),
            "switch(buffer, ...) should read ctrl from shared ring buffer: {}",
            cpp
        );
    }

    #[test]
    fn switch_default_clause_has_no_codegen_fallback() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "clock 1kHz t {\n",
                "    control {\n        constant(0.0) | detect() -> ctrl\n    }\n",
                "    mode a {\n        constant(0.0) | stdout()\n    }\n",
                "    mode b {\n        constant(0.0) | stdout()\n    }\n",
                "    switch(ctrl, a, b) default a\n",
                "}\n"
            ),
            &reg,
        );
        assert!(
            cpp.contains("switch (_ctrl)"),
            "modal task should dispatch by ctrl value: {}",
            cpp
        );
        assert!(
            cpp.contains("default: break;"),
            "out-of-range ctrl should not force fallback mode: {}",
            cpp
        );
        assert!(
            !cpp.contains("_ringbuf_ctrl.write("),
            "internally consumed switch ctrl should not be written to shared ring buffer: {}",
            cpp
        );
    }

    #[test]
    fn feedback_pdl_codegen() {
        let reg = test_registry();
        let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("examples/feedback.pdl");
        let source = std::fs::read_to_string(&path).expect("failed to read feedback.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(
            cpp.contains("_fb_"),
            "feedback.pdl should have feedback buffer: {}",
            cpp
        );
        assert!(
            cpp.contains("Actor_delay"),
            "feedback.pdl should have delay actor"
        );
    }

    // ── Polymorphic actor tests (v0.3.0) ─────────────────────────────────

    fn poly_registry() -> Registry {
        let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .to_path_buf();
        let mut reg = test_registry();
        let poly_actors = root.join("examples/poly_actors.h");
        reg.load_header(&poly_actors)
            .expect("failed to load poly_actors.h");
        reg
    }

    /// Run the full pipeline (with type_infer + lower) and return generated C++.
    fn codegen_poly_ok(source: &str, registry: &Registry) -> String {
        let parse_result = crate::parser::parse(source);
        assert!(
            parse_result.errors.is_empty(),
            "parse errors: {:?}",
            parse_result.errors
        );
        let program = parse_result.program.expect("parse failed");
        let mut resolve_result = resolve::resolve(&program, registry);
        assert!(
            resolve_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "resolve errors: {:#?}",
            resolve_result.diagnostics
        );

        // Build HIR
        let hir_program = crate::hir::build_hir(
            &program,
            &resolve_result.resolved,
            &mut resolve_result.id_alloc,
        );

        // Type inference
        let type_infer_result =
            crate::type_infer::type_infer(&hir_program, &resolve_result.resolved, registry);
        assert!(
            type_infer_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "type_infer errors: {:#?}",
            type_infer_result.diagnostics
        );

        // Lowering
        let lower_result = crate::lower::lower_and_verify(
            &hir_program,
            &resolve_result.resolved,
            &type_infer_result.typed,
            registry,
        );
        assert!(
            !lower_result.has_errors(),
            "lower errors: {:#?}",
            lower_result.diagnostics
        );
        assert!(
            lower_result.cert.all_pass(),
            "L1-L5 cert failed: {:?}",
            lower_result.cert
        );
        let graph_result =
            crate::graph::build_graph(&hir_program, &resolve_result.resolved, registry);
        assert!(
            graph_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "graph errors: {:#?}",
            graph_result.diagnostics
        );
        let thir = crate::thir::build_thir_context(
            &hir_program,
            &resolve_result.resolved,
            &type_infer_result.typed,
            &lower_result.lowered,
            registry,
            &graph_result.graph,
        );
        let analysis_result = crate::analyze::analyze(&thir, &graph_result.graph);
        assert!(
            analysis_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "analysis errors: {:#?}",
            analysis_result.diagnostics
        );
        let schedule_result =
            crate::schedule::schedule(&thir, &graph_result.graph, &analysis_result.analysis);
        assert!(
            schedule_result
                .diagnostics
                .iter()
                .all(|d| d.level != DiagLevel::Error),
            "schedule errors: {:#?}",
            schedule_result.diagnostics
        );

        let lir = crate::lir::build_lir(
            &thir,
            &graph_result.graph,
            &analysis_result.analysis,
            &schedule_result.schedule,
        );
        let options = CodegenOptions {
            release: false,
            include_paths: vec![],
            provenance: None,
        };
        let mut ctx = CodegenCtx::new(
            &graph_result.graph,
            &schedule_result.schedule,
            &options,
            &lir,
        );
        ctx.emit_all();
        let result = ctx.build_result();
        let errors: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| d.level == DiagLevel::Error)
            .collect();
        assert!(
            errors.is_empty(),
            "unexpected codegen errors: {:#?}",
            errors
        );
        result.generated.cpp_source
    }

    #[test]
    fn poly_scale_explicit_float_template_syntax() {
        let reg = poly_registry();
        let cpp = codegen_poly_ok(
            "clock 1kHz t { constant(0.0) | poly_scale<float>(2.0) | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("Actor_poly_scale<float>"),
            "should emit template instantiation Actor_poly_scale<float>, got:\n{}",
            cpp
        );
    }

    #[test]
    fn poly_pass_explicit_float_template_syntax() {
        let reg = poly_registry();
        let cpp = codegen_poly_ok(
            "clock 1kHz t { constant(0.0) | poly_pass<float>() | stdout() }",
            &reg,
        );
        assert!(
            cpp.contains("Actor_poly_pass<float>"),
            "should emit Actor_poly_pass<float>, got:\n{}",
            cpp
        );
    }

    #[test]
    fn poly_now_polymorphic_constant() {
        // constant and stdout are now polymorphic — should emit template syntax
        let reg = poly_registry();
        let cpp = codegen_poly_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        assert!(
            cpp.contains("Actor_constant<float>"),
            "polymorphic constant should use Actor_constant<float> syntax, got:\n{}",
            cpp
        );
        assert!(
            cpp.contains("Actor_stdout<float>"),
            "polymorphic stdout should use Actor_stdout<float> syntax, got:\n{}",
            cpp
        );
    }

    // ── v0.3.1 regression tests ─────────────────────────────────────────

    #[test]
    fn fir_span_derived_param_in_codegen() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "const coeff = [0.1, 0.2, 0.4, 0.2, 0.1]\nclock 1kHz t { constant(0.0) | fir(coeff) | stdout() }",
            &reg,
        );
        // fir actor constructor should have N=5 from span-derived dim
        assert!(
            cpp.contains(", 5}"),
            "fir actor should have N=5 from span-derived dim, got:\n{}",
            cpp
        );
    }

    #[test]
    fn fir_span_derived_not_overridden_by_edge_inference() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "const coeff = [0.1, 0.2, 0.4, 0.2, 0.1]\n",
                "clock 1kHz t { constant(0.0) | fft(256) | c2r() | fir(coeff) | stdout() }",
            ),
            &reg,
        );
        // Even with fft(256) upstream producing 256 tokens, fir N should be 5
        assert!(
            cpp.contains("Actor_fir") && cpp.contains(", 5}"),
            "fir should have N=5 even after fft(256)|c2r(), not 256, got:\n{}",
            cpp
        );
        // fir's constructor should NOT contain 256 as its N param
        assert!(
            !cpp.contains("Actor_fir")
                || !cpp.contains("Actor_fir<float>{std::span<const float>(_const_coeff, 5), 256}"),
            "fir should NOT have N=256 from edge inference, got:\n{}",
            cpp
        );
    }

    #[test]
    fn shared_buffer_block_transfer() {
        let reg = test_registry();
        let cpp = codegen_ok(
            concat!(
                "set mem = 64MB\n",
                "clock 1kHz a { constant(0.0) -> sig }\n",
                "clock 1kHz b { @sig | stdout() }\n",
            ),
            &reg,
        );
        // Ring buffer read/write should use base buffer pointer (no &buf[_r*N] offset)
        assert!(
            !cpp.contains("_ringbuf_sig.write(&_"),
            "ring buffer write should NOT use per-firing pointer offset (block transfer), got:\n{}",
            cpp
        );
        assert!(
            !cpp.contains("_ringbuf_sig.read(0, &_"),
            "ring buffer read should NOT use per-firing pointer offset (block transfer), got:\n{}",
            cpp
        );
    }

    #[test]
    fn actor_construction_hoisted_for_repetition() {
        let reg = test_registry();
        let cpp = codegen_ok(
            "clock 1kHz t { constant(0.0) | fft(256) | c2r() | stdout() }",
            &reg,
        );
        // c2r has rep=256. Its actor should be hoisted before the _r loop.
        assert!(
            cpp.contains("auto _actor_"),
            "hoistable actor with rep>1 should have pre-loop declaration, got:\n{}",
            cpp
        );
        // The hoisted actor should be called via .operator() inside the loop
        assert!(
            cpp.contains("_actor_") && cpp.contains(".operator()("),
            "hoisted actor should be called via .operator() inside the loop, got:\n{}",
            cpp
        );
    }

    #[test]
    fn actor_construction_hoisted_before_k_loop() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 10MHz t { constant(0.0) | stdout() }", &reg);
        let task_start = cpp.find("void task_t()").expect("missing task_t");
        let task_tail = &cpp[task_start..];
        let task_end = task_tail.find("int main(").unwrap_or(task_tail.len());
        let task = &task_tail[..task_end];

        let decl_pos = task
            .find("auto _actor_")
            .expect("expected hoisted actor declaration in task_t");
        let k_pos = task
            .find("for (int _k = 0; _k < ")
            .expect("expected k-loop in task_t");
        assert!(
            decl_pos < k_pos,
            "actor should be hoisted before _k loop in task_t, got:\n{}",
            task
        );
    }

    #[test]
    fn multi_input_single_token_edges_avoid_memcpy() {
        let reg = test_registry();
        let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let root = manifest_dir.parent().expect("missing workspace root");
        let path = root.join("examples/feedback.pdl");
        let source = std::fs::read_to_string(path).expect("failed to read feedback.pdl");
        let cpp = codegen_ok(&source, &reg);
        assert!(
            !cpp.contains("std::memcpy(&_in_"),
            "single-token multi-input copies should use direct assignments, got:\n{}",
            cpp
        );
        assert!(
            cpp.contains("_in_") && cpp.contains("[0] = (") && cpp.contains("[1] = ("),
            "feedback add input packing should still populate local input slots, got:\n{}",
            cpp
        );
    }

    #[test]
    fn provenance_comment_emitted() {
        let reg = test_registry();
        let prov = crate::pipeline::Provenance {
            source_hash: [0xab; 32],
            registry_fingerprint: [0xcd; 32],
            compiler_version: "0.1.2-test",
        };
        let result = codegen_source_with_options(
            "clock 1kHz t { constant(0.0) | stdout() }",
            &reg,
            CodegenOptions {
                release: false,
                include_paths: vec![],
                provenance: Some(prov),
            },
        );
        let cpp = result.generated.cpp_source;
        let first_line = cpp.lines().next().unwrap();
        assert!(
            first_line.starts_with("// pcc provenance:"),
            "first line should be provenance comment, got: {}",
            first_line
        );
        assert!(
            first_line.contains(
                "source_hash=abababababababababababababababababababababababababababababababab"
            ),
            "should contain source_hash hex"
        );
        assert!(
            first_line.contains("registry_fingerprint=cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"),
            "should contain registry_fingerprint hex"
        );
        assert!(
            first_line.contains("version=0.1.2-test"),
            "should contain compiler version"
        );
    }

    #[test]
    fn no_provenance_comment_when_none() {
        let reg = test_registry();
        let cpp = codegen_ok("clock 1kHz t { constant(0.0) | stdout() }", &reg);
        let first_line = cpp.lines().next().unwrap();
        assert!(
            first_line.starts_with("// Generated by pcc"),
            "without provenance, first line should be the standard header, got: {}",
            first_line
        );
    }
}
