# Benchmark Results: v0.4.7 RingBuffer Wait-Loop

**Date**: 2026-03-01
**Commit**: 49c6abb (v0.4.7 WIP)
**Focus**: Wait-enabled ring buffer benchmarks

## Ring Buffer Results

| Benchmark | Time | Items/sec | Notes |
|-----------|------|-----------|-------|
| BM_RingBuffer_Throughput | 0.77 ms | 1,426,482 | Raw SPSC (no wait) |
| BM_RingBuffer_WaitThroughput | 10.87 ms | 1,796,271 | Wait-enabled SPSC |
| BM_RingBuffer_WaitLatency | 1,180 us | — | Wakeup: ~1.1ms |
| BM_RingBuffer_Contention/1reader | 398 us | 670M | |
| BM_RingBuffer_Contention/2readers | 600 us | 439M | |
| BM_RingBuffer_Contention/4readers | 1,137 us | 227M | |
| BM_RingBuffer_Contention/8readers | 3,146 us | 81M | |

## Analysis

- **Wait throughput**: 1.8M items/s — comparable to raw throughput (1.4M), suggesting
  hybrid polling adds minimal overhead under sustained load.
- **Wait latency**: ~1.1ms wakeup from sleep phase. Expected since the benchmark introduces
  a 100us writer delay, causing the reader to exhaust spin (100 iters) and yield (100 iters)
  phases before entering 1ms sleep. Actual data-available wakeup during spin/yield phases
  would be sub-microsecond.
- **Contention scaling**: 1→8 readers shows expected degradation (~8x) due to cache-line
  contention on writer's min-tail scan.

## Configuration

- Platform: Linux 6.6.87 (WSL2), x86_64
- Compiler: c++ (g++), -O3 -march=native
- C++ Standard: C++20
